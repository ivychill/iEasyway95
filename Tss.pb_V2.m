// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "Tss.pb.h"

@implementation TssRoot
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [TssRoot class]) {
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    extensionRegistry = [registry retain];
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
}
@end

BOOL TSSDirectionIsValidValue(TSSDirection value) {
  switch (value) {
    case TSSDirectionUnknown:
    case TSSDirectionEast:
    case TSSDirectionNortheast:
    case TSSDirectionNorth:
    case TSSDirectionNorthwest:
    case TSSDirectionWest:
    case TSSDirectionSouthwest:
    case TSSDirectionSouth:
    case TSSDirectionSoutheast:
      return YES;
    default:
      return NO;
  }
}
BOOL TSSOprTypeIsValidValue(TSSOprType value) {
  switch (value) {
    case TSSOprTypeSubCreate:
    case TSSOprTypeSubDelete:
    case TSSOprTypeSubUpdate:
      return YES;
    default:
      return NO;
  }
}
BOOL TSSPubTypeIsValidValue(TSSPubType value) {
  switch (value) {
    case TSSPubTypePubOnce:
    case TSSPubTypePubEvent:
    case TSSPubTypePubTimer:
      return YES;
    default:
      return NO;
  }
}
BOOL TSSErrCodeIsValidValue(TSSErrCode value) {
  switch (value) {
    case TSSErrCodeVersionImcompatible:
    case TSSErrCodeVersionLow:
    case TSSErrCodeMsgDirError:
    case TSSErrCodeMsgTypeError:
    case TSSErrCodeTimeout:
    case TSSErrCodeOthers:
      return YES;
    default:
      return NO;
  }
}
BOOL TSSMsgDirIsValidValue(TSSMsgDir value) {
  switch (value) {
    case TSSMsgDirClient2Tss:
    case TSSMsgDirTss2Client:
      return YES;
    default:
      return NO;
  }
}
BOOL TSSMsgTypeIsValidValue(TSSMsgType value) {
  switch (value) {
    case TSSMsgTypeVoid:
    case TSSMsgTypeErrCode:
    case TSSMsgTypeTrafficSub:
    case TSSMsgTypeTrafficReport:
    case TSSMsgTypeDeviceReport:
    case TSSMsgTypeCityTrafficPub:
      return YES;
    default:
      return NO;
  }
}
@interface TSSCoordinate ()
@property Float64 lng;
@property Float64 lat;
@end

@implementation TSSCoordinate

- (BOOL) hasLng {
  return !!hasLng_;
}
- (void) setHasLng:(BOOL) value {
  hasLng_ = !!value;
}
@synthesize lng;
- (BOOL) hasLat {
  return !!hasLat_;
}
- (void) setHasLat:(BOOL) value {
  hasLat_ = !!value;
}
@synthesize lat;
- (void) dealloc {
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.lng = 0;
    self.lat = 0;
  }
  return self;
}
static TSSCoordinate* defaultTSSCoordinateInstance = nil;
+ (void) initialize {
  if (self == [TSSCoordinate class]) {
    defaultTSSCoordinateInstance = [[TSSCoordinate alloc] init];
  }
}
+ (TSSCoordinate*) defaultInstance {
  return defaultTSSCoordinateInstance;
}
- (TSSCoordinate*) defaultInstance {
  return defaultTSSCoordinateInstance;
}
- (BOOL) isInitialized {
  if (!self.hasLng) {
    return NO;
  }
  if (!self.hasLat) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasLng) {
    [output writeDouble:1 value:self.lng];
  }
  if (self.hasLat) {
    [output writeDouble:2 value:self.lat];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasLng) {
    size += computeDoubleSize(1, self.lng);
  }
  if (self.hasLat) {
    size += computeDoubleSize(2, self.lat);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSSCoordinate*) parseFromData:(NSData*) data {
  return (TSSCoordinate*)[[[TSSCoordinate builder] mergeFromData:data] build];
}
+ (TSSCoordinate*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSCoordinate*)[[[TSSCoordinate builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSSCoordinate*) parseFromInputStream:(NSInputStream*) input {
  return (TSSCoordinate*)[[[TSSCoordinate builder] mergeFromInputStream:input] build];
}
+ (TSSCoordinate*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSCoordinate*)[[[TSSCoordinate builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSCoordinate*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSSCoordinate*)[[[TSSCoordinate builder] mergeFromCodedInputStream:input] build];
}
+ (TSSCoordinate*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSCoordinate*)[[[TSSCoordinate builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSCoordinate_Builder*) builder {
  return [[[TSSCoordinate_Builder alloc] init] autorelease];
}
+ (TSSCoordinate_Builder*) builderWithPrototype:(TSSCoordinate*) prototype {
  return [[TSSCoordinate builder] mergeFrom:prototype];
}
- (TSSCoordinate_Builder*) builder {
  return [TSSCoordinate builder];
}
@end

@interface TSSCoordinate_Builder()
@property (retain) TSSCoordinate* result;
@end

@implementation TSSCoordinate_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSSCoordinate alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSSCoordinate_Builder*) clear {
  self.result = [[[TSSCoordinate alloc] init] autorelease];
  return self;
}
- (TSSCoordinate_Builder*) clone {
  return [TSSCoordinate builderWithPrototype:result];
}
- (TSSCoordinate*) defaultInstance {
  return [TSSCoordinate defaultInstance];
}
- (TSSCoordinate*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSSCoordinate*) buildPartial {
  TSSCoordinate* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSSCoordinate_Builder*) mergeFrom:(TSSCoordinate*) other {
  if (other == [TSSCoordinate defaultInstance]) {
    return self;
  }
  if (other.hasLng) {
    [self setLng:other.lng];
  }
  if (other.hasLat) {
    [self setLat:other.lat];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSSCoordinate_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSSCoordinate_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 9: {
        [self setLng:[input readDouble]];
        break;
      }
      case 17: {
        [self setLat:[input readDouble]];
        break;
      }
    }
  }
}
- (BOOL) hasLng {
  return result.hasLng;
}
- (Float64) lng {
  return result.lng;
}
- (TSSCoordinate_Builder*) setLng:(Float64) value {
  result.hasLng = YES;
  result.lng = value;
  return self;
}
- (TSSCoordinate_Builder*) clearLng {
  result.hasLng = NO;
  result.lng = 0;
  return self;
}
- (BOOL) hasLat {
  return result.hasLat;
}
- (Float64) lat {
  return result.lat;
}
- (TSSCoordinate_Builder*) setLat:(Float64) value {
  result.hasLat = YES;
  result.lat = value;
  return self;
}
- (TSSCoordinate_Builder*) clearLat {
  result.hasLat = NO;
  result.lat = 0;
  return self;
}
@end

@interface TSSLocation ()
@property Float64 lng;
@property Float64 lat;
@property (retain) NSString* name;
@property (retain) NSString* adt;
@end

@implementation TSSLocation

- (BOOL) hasLng {
  return !!hasLng_;
}
- (void) setHasLng:(BOOL) value {
  hasLng_ = !!value;
}
@synthesize lng;
- (BOOL) hasLat {
  return !!hasLat_;
}
- (void) setHasLat:(BOOL) value {
  hasLat_ = !!value;
}
@synthesize lat;
- (BOOL) hasName {
  return !!hasName_;
}
- (void) setHasName:(BOOL) value {
  hasName_ = !!value;
}
@synthesize name;
- (BOOL) hasAdt {
  return !!hasAdt_;
}
- (void) setHasAdt:(BOOL) value {
  hasAdt_ = !!value;
}
@synthesize adt;
- (void) dealloc {
  self.name = nil;
  self.adt = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.lng = 0;
    self.lat = 0;
    self.name = @"";
    self.adt = @"";
  }
  return self;
}
static TSSLocation* defaultTSSLocationInstance = nil;
+ (void) initialize {
  if (self == [TSSLocation class]) {
    defaultTSSLocationInstance = [[TSSLocation alloc] init];
  }
}
+ (TSSLocation*) defaultInstance {
  return defaultTSSLocationInstance;
}
- (TSSLocation*) defaultInstance {
  return defaultTSSLocationInstance;
}
- (BOOL) isInitialized {
  if (!self.hasLng) {
    return NO;
  }
  if (!self.hasLat) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasLng) {
    [output writeDouble:1 value:self.lng];
  }
  if (self.hasLat) {
    [output writeDouble:2 value:self.lat];
  }
  if (self.hasName) {
    [output writeString:3 value:self.name];
  }
  if (self.hasAdt) {
    [output writeString:11 value:self.adt];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasLng) {
    size += computeDoubleSize(1, self.lng);
  }
  if (self.hasLat) {
    size += computeDoubleSize(2, self.lat);
  }
  if (self.hasName) {
    size += computeStringSize(3, self.name);
  }
  if (self.hasAdt) {
    size += computeStringSize(11, self.adt);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSSLocation*) parseFromData:(NSData*) data {
  return (TSSLocation*)[[[TSSLocation builder] mergeFromData:data] build];
}
+ (TSSLocation*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSLocation*)[[[TSSLocation builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSSLocation*) parseFromInputStream:(NSInputStream*) input {
  return (TSSLocation*)[[[TSSLocation builder] mergeFromInputStream:input] build];
}
+ (TSSLocation*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSLocation*)[[[TSSLocation builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSLocation*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSSLocation*)[[[TSSLocation builder] mergeFromCodedInputStream:input] build];
}
+ (TSSLocation*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSLocation*)[[[TSSLocation builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSLocation_Builder*) builder {
  return [[[TSSLocation_Builder alloc] init] autorelease];
}
+ (TSSLocation_Builder*) builderWithPrototype:(TSSLocation*) prototype {
  return [[TSSLocation builder] mergeFrom:prototype];
}
- (TSSLocation_Builder*) builder {
  return [TSSLocation builder];
}
@end

@interface TSSLocation_Builder()
@property (retain) TSSLocation* result;
@end

@implementation TSSLocation_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSSLocation alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSSLocation_Builder*) clear {
  self.result = [[[TSSLocation alloc] init] autorelease];
  return self;
}
- (TSSLocation_Builder*) clone {
  return [TSSLocation builderWithPrototype:result];
}
- (TSSLocation*) defaultInstance {
  return [TSSLocation defaultInstance];
}
- (TSSLocation*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSSLocation*) buildPartial {
  TSSLocation* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSSLocation_Builder*) mergeFrom:(TSSLocation*) other {
  if (other == [TSSLocation defaultInstance]) {
    return self;
  }
  if (other.hasLng) {
    [self setLng:other.lng];
  }
  if (other.hasLat) {
    [self setLat:other.lat];
  }
  if (other.hasName) {
    [self setName:other.name];
  }
  if (other.hasAdt) {
    [self setAdt:other.adt];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSSLocation_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSSLocation_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 9: {
        [self setLng:[input readDouble]];
        break;
      }
      case 17: {
        [self setLat:[input readDouble]];
        break;
      }
      case 26: {
        [self setName:[input readString]];
        break;
      }
      case 90: {
        [self setAdt:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasLng {
  return result.hasLng;
}
- (Float64) lng {
  return result.lng;
}
- (TSSLocation_Builder*) setLng:(Float64) value {
  result.hasLng = YES;
  result.lng = value;
  return self;
}
- (TSSLocation_Builder*) clearLng {
  result.hasLng = NO;
  result.lng = 0;
  return self;
}
- (BOOL) hasLat {
  return result.hasLat;
}
- (Float64) lat {
  return result.lat;
}
- (TSSLocation_Builder*) setLat:(Float64) value {
  result.hasLat = YES;
  result.lat = value;
  return self;
}
- (TSSLocation_Builder*) clearLat {
  result.hasLat = NO;
  result.lat = 0;
  return self;
}
- (BOOL) hasName {
  return result.hasName;
}
- (NSString*) name {
  return result.name;
}
- (TSSLocation_Builder*) setName:(NSString*) value {
  result.hasName = YES;
  result.name = value;
  return self;
}
- (TSSLocation_Builder*) clearName {
  result.hasName = NO;
  result.name = @"";
  return self;
}
- (BOOL) hasAdt {
  return result.hasAdt;
}
- (NSString*) adt {
  return result.adt;
}
- (TSSLocation_Builder*) setAdt:(NSString*) value {
  result.hasAdt = YES;
  result.adt = value;
  return self;
}
- (TSSLocation_Builder*) clearAdt {
  result.hasAdt = NO;
  result.adt = @"";
  return self;
}
@end

@interface TSSSegment ()
@property (retain) TSSCoordinate* start;
@property (retain) TSSCoordinate* end;
@property (retain) NSString* road;
@end

@implementation TSSSegment

- (BOOL) hasStart {
  return !!hasStart_;
}
- (void) setHasStart:(BOOL) value {
  hasStart_ = !!value;
}
@synthesize start;
- (BOOL) hasEnd {
  return !!hasEnd_;
}
- (void) setHasEnd:(BOOL) value {
  hasEnd_ = !!value;
}
@synthesize end;
- (BOOL) hasRoad {
  return !!hasRoad_;
}
- (void) setHasRoad:(BOOL) value {
  hasRoad_ = !!value;
}
@synthesize road;
- (void) dealloc {
  self.start = nil;
  self.end = nil;
  self.road = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.start = [TSSCoordinate defaultInstance];
    self.end = [TSSCoordinate defaultInstance];
    self.road = @"";
  }
  return self;
}
static TSSSegment* defaultTSSSegmentInstance = nil;
+ (void) initialize {
  if (self == [TSSSegment class]) {
    defaultTSSSegmentInstance = [[TSSSegment alloc] init];
  }
}
+ (TSSSegment*) defaultInstance {
  return defaultTSSSegmentInstance;
}
- (TSSSegment*) defaultInstance {
  return defaultTSSSegmentInstance;
}
- (BOOL) isInitialized {
  if (!self.hasStart) {
    return NO;
  }
  if (!self.hasEnd) {
    return NO;
  }
  if (!self.start.isInitialized) {
    return NO;
  }
  if (!self.end.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasStart) {
    [output writeMessage:1 value:self.start];
  }
  if (self.hasEnd) {
    [output writeMessage:2 value:self.end];
  }
  if (self.hasRoad) {
    [output writeString:3 value:self.road];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasStart) {
    size += computeMessageSize(1, self.start);
  }
  if (self.hasEnd) {
    size += computeMessageSize(2, self.end);
  }
  if (self.hasRoad) {
    size += computeStringSize(3, self.road);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSSSegment*) parseFromData:(NSData*) data {
  return (TSSSegment*)[[[TSSSegment builder] mergeFromData:data] build];
}
+ (TSSSegment*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSSegment*)[[[TSSSegment builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSSSegment*) parseFromInputStream:(NSInputStream*) input {
  return (TSSSegment*)[[[TSSSegment builder] mergeFromInputStream:input] build];
}
+ (TSSSegment*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSSegment*)[[[TSSSegment builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSSegment*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSSSegment*)[[[TSSSegment builder] mergeFromCodedInputStream:input] build];
}
+ (TSSSegment*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSSegment*)[[[TSSSegment builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSSegment_Builder*) builder {
  return [[[TSSSegment_Builder alloc] init] autorelease];
}
+ (TSSSegment_Builder*) builderWithPrototype:(TSSSegment*) prototype {
  return [[TSSSegment builder] mergeFrom:prototype];
}
- (TSSSegment_Builder*) builder {
  return [TSSSegment builder];
}
@end

@interface TSSSegment_Builder()
@property (retain) TSSSegment* result;
@end

@implementation TSSSegment_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSSSegment alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSSSegment_Builder*) clear {
  self.result = [[[TSSSegment alloc] init] autorelease];
  return self;
}
- (TSSSegment_Builder*) clone {
  return [TSSSegment builderWithPrototype:result];
}
- (TSSSegment*) defaultInstance {
  return [TSSSegment defaultInstance];
}
- (TSSSegment*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSSSegment*) buildPartial {
  TSSSegment* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSSSegment_Builder*) mergeFrom:(TSSSegment*) other {
  if (other == [TSSSegment defaultInstance]) {
    return self;
  }
  if (other.hasStart) {
    [self mergeStart:other.start];
  }
  if (other.hasEnd) {
    [self mergeEnd:other.end];
  }
  if (other.hasRoad) {
    [self setRoad:other.road];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSSSegment_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSSSegment_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        TSSCoordinate_Builder* subBuilder = [TSSCoordinate builder];
        if (self.hasStart) {
          [subBuilder mergeFrom:self.start];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setStart:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        TSSCoordinate_Builder* subBuilder = [TSSCoordinate builder];
        if (self.hasEnd) {
          [subBuilder mergeFrom:self.end];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setEnd:[subBuilder buildPartial]];
        break;
      }
      case 26: {
        [self setRoad:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasStart {
  return result.hasStart;
}
- (TSSCoordinate*) start {
  return result.start;
}
- (TSSSegment_Builder*) setStart:(TSSCoordinate*) value {
  result.hasStart = YES;
  result.start = value;
  return self;
}
- (TSSSegment_Builder*) setStartBuilder:(TSSCoordinate_Builder*) builderForValue {
  return [self setStart:[builderForValue build]];
}
- (TSSSegment_Builder*) mergeStart:(TSSCoordinate*) value {
  if (result.hasStart &&
      result.start != [TSSCoordinate defaultInstance]) {
    result.start =
      [[[TSSCoordinate builderWithPrototype:result.start] mergeFrom:value] buildPartial];
  } else {
    result.start = value;
  }
  result.hasStart = YES;
  return self;
}
- (TSSSegment_Builder*) clearStart {
  result.hasStart = NO;
  result.start = [TSSCoordinate defaultInstance];
  return self;
}
- (BOOL) hasEnd {
  return result.hasEnd;
}
- (TSSCoordinate*) end {
  return result.end;
}
- (TSSSegment_Builder*) setEnd:(TSSCoordinate*) value {
  result.hasEnd = YES;
  result.end = value;
  return self;
}
- (TSSSegment_Builder*) setEndBuilder:(TSSCoordinate_Builder*) builderForValue {
  return [self setEnd:[builderForValue build]];
}
- (TSSSegment_Builder*) mergeEnd:(TSSCoordinate*) value {
  if (result.hasEnd &&
      result.end != [TSSCoordinate defaultInstance]) {
    result.end =
      [[[TSSCoordinate builderWithPrototype:result.end] mergeFrom:value] buildPartial];
  } else {
    result.end = value;
  }
  result.hasEnd = YES;
  return self;
}
- (TSSSegment_Builder*) clearEnd {
  result.hasEnd = NO;
  result.end = [TSSCoordinate defaultInstance];
  return self;
}
- (BOOL) hasRoad {
  return result.hasRoad;
}
- (NSString*) road {
  return result.road;
}
- (TSSSegment_Builder*) setRoad:(NSString*) value {
  result.hasRoad = YES;
  result.road = value;
  return self;
}
- (TSSSegment_Builder*) clearRoad {
  result.hasRoad = NO;
  result.road = @"";
  return self;
}
@end

@interface TSSRoute ()
@property int64_t identity;
@property (retain) NSMutableArray* mutableSegmentsList;
@end

@implementation TSSRoute

- (BOOL) hasIdentity {
  return !!hasIdentity_;
}
- (void) setHasIdentity:(BOOL) value {
  hasIdentity_ = !!value;
}
@synthesize identity;
@synthesize mutableSegmentsList;
- (void) dealloc {
  self.mutableSegmentsList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.identity = 0L;
  }
  return self;
}
static TSSRoute* defaultTSSRouteInstance = nil;
+ (void) initialize {
  if (self == [TSSRoute class]) {
    defaultTSSRouteInstance = [[TSSRoute alloc] init];
  }
}
+ (TSSRoute*) defaultInstance {
  return defaultTSSRouteInstance;
}
- (TSSRoute*) defaultInstance {
  return defaultTSSRouteInstance;
}
- (NSArray*) segmentsList {
  return mutableSegmentsList;
}
- (TSSSegment*) segmentsAtIndex:(int32_t) index {
  id value = [mutableSegmentsList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasIdentity) {
    return NO;
  }
  for (TSSSegment* element in self.segmentsList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasIdentity) {
    [output writeInt64:1 value:self.identity];
  }
  for (TSSSegment* element in self.segmentsList) {
    [output writeMessage:2 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasIdentity) {
    size += computeInt64Size(1, self.identity);
  }
  for (TSSSegment* element in self.segmentsList) {
    size += computeMessageSize(2, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSSRoute*) parseFromData:(NSData*) data {
  return (TSSRoute*)[[[TSSRoute builder] mergeFromData:data] build];
}
+ (TSSRoute*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSRoute*)[[[TSSRoute builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSSRoute*) parseFromInputStream:(NSInputStream*) input {
  return (TSSRoute*)[[[TSSRoute builder] mergeFromInputStream:input] build];
}
+ (TSSRoute*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSRoute*)[[[TSSRoute builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSRoute*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSSRoute*)[[[TSSRoute builder] mergeFromCodedInputStream:input] build];
}
+ (TSSRoute*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSRoute*)[[[TSSRoute builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSRoute_Builder*) builder {
  return [[[TSSRoute_Builder alloc] init] autorelease];
}
+ (TSSRoute_Builder*) builderWithPrototype:(TSSRoute*) prototype {
  return [[TSSRoute builder] mergeFrom:prototype];
}
- (TSSRoute_Builder*) builder {
  return [TSSRoute builder];
}
@end

@interface TSSRoute_Builder()
@property (retain) TSSRoute* result;
@end

@implementation TSSRoute_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSSRoute alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSSRoute_Builder*) clear {
  self.result = [[[TSSRoute alloc] init] autorelease];
  return self;
}
- (TSSRoute_Builder*) clone {
  return [TSSRoute builderWithPrototype:result];
}
- (TSSRoute*) defaultInstance {
  return [TSSRoute defaultInstance];
}
- (TSSRoute*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSSRoute*) buildPartial {
  TSSRoute* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSSRoute_Builder*) mergeFrom:(TSSRoute*) other {
  if (other == [TSSRoute defaultInstance]) {
    return self;
  }
  if (other.hasIdentity) {
    [self setIdentity:other.identity];
  }
  if (other.mutableSegmentsList.count > 0) {
    if (result.mutableSegmentsList == nil) {
      result.mutableSegmentsList = [NSMutableArray array];
    }
    [result.mutableSegmentsList addObjectsFromArray:other.mutableSegmentsList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSSRoute_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSSRoute_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setIdentity:[input readInt64]];
        break;
      }
      case 18: {
        TSSSegment_Builder* subBuilder = [TSSSegment builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addSegments:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasIdentity {
  return result.hasIdentity;
}
- (int64_t) identity {
  return result.identity;
}
- (TSSRoute_Builder*) setIdentity:(int64_t) value {
  result.hasIdentity = YES;
  result.identity = value;
  return self;
}
- (TSSRoute_Builder*) clearIdentity {
  result.hasIdentity = NO;
  result.identity = 0L;
  return self;
}
- (NSArray*) segmentsList {
  if (result.mutableSegmentsList == nil) { return [NSArray array]; }
  return result.mutableSegmentsList;
}
- (TSSSegment*) segmentsAtIndex:(int32_t) index {
  return [result segmentsAtIndex:index];
}
- (TSSRoute_Builder*) replaceSegmentsAtIndex:(int32_t) index with:(TSSSegment*) value {
  [result.mutableSegmentsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (TSSRoute_Builder*) addAllSegments:(NSArray*) values {
  if (result.mutableSegmentsList == nil) {
    result.mutableSegmentsList = [NSMutableArray array];
  }
  [result.mutableSegmentsList addObjectsFromArray:values];
  return self;
}
- (TSSRoute_Builder*) clearSegmentsList {
  result.mutableSegmentsList = nil;
  return self;
}
- (TSSRoute_Builder*) addSegments:(TSSSegment*) value {
  if (result.mutableSegmentsList == nil) {
    result.mutableSegmentsList = [NSMutableArray array];
  }
  [result.mutableSegmentsList addObject:value];
  return self;
}
@end

@interface TSSTrafficProbe ()
@property (retain) TSSSegment* segment;
@property (retain) TSSCoordinate* location;
@property int64_t timestamp;
@property TSSDirection direction;
@property int32_t speed;
@property int32_t acceleration;
@end

@implementation TSSTrafficProbe

- (BOOL) hasSegment {
  return !!hasSegment_;
}
- (void) setHasSegment:(BOOL) value {
  hasSegment_ = !!value;
}
@synthesize segment;
- (BOOL) hasLocation {
  return !!hasLocation_;
}
- (void) setHasLocation:(BOOL) value {
  hasLocation_ = !!value;
}
@synthesize location;
- (BOOL) hasTimestamp {
  return !!hasTimestamp_;
}
- (void) setHasTimestamp:(BOOL) value {
  hasTimestamp_ = !!value;
}
@synthesize timestamp;
- (BOOL) hasDirection {
  return !!hasDirection_;
}
- (void) setHasDirection:(BOOL) value {
  hasDirection_ = !!value;
}
@synthesize direction;
- (BOOL) hasSpeed {
  return !!hasSpeed_;
}
- (void) setHasSpeed:(BOOL) value {
  hasSpeed_ = !!value;
}
@synthesize speed;
- (BOOL) hasAcceleration {
  return !!hasAcceleration_;
}
- (void) setHasAcceleration:(BOOL) value {
  hasAcceleration_ = !!value;
}
@synthesize acceleration;
- (void) dealloc {
  self.segment = nil;
  self.location = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.segment = [TSSSegment defaultInstance];
    self.location = [TSSCoordinate defaultInstance];
    self.timestamp = 0L;
    self.direction = TSSDirectionUnknown;
    self.speed = 0;
    self.acceleration = 0;
  }
  return self;
}
static TSSTrafficProbe* defaultTSSTrafficProbeInstance = nil;
+ (void) initialize {
  if (self == [TSSTrafficProbe class]) {
    defaultTSSTrafficProbeInstance = [[TSSTrafficProbe alloc] init];
  }
}
+ (TSSTrafficProbe*) defaultInstance {
  return defaultTSSTrafficProbeInstance;
}
- (TSSTrafficProbe*) defaultInstance {
  return defaultTSSTrafficProbeInstance;
}
- (BOOL) isInitialized {
  if (!self.hasDirection) {
    return NO;
  }
  if (!self.hasSpeed) {
    return NO;
  }
  if (self.hasSegment) {
    if (!self.segment.isInitialized) {
      return NO;
    }
  }
  if (self.hasLocation) {
    if (!self.location.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasSegment) {
    [output writeMessage:1 value:self.segment];
  }
  if (self.hasLocation) {
    [output writeMessage:2 value:self.location];
  }
  if (self.hasTimestamp) {
    [output writeInt64:3 value:self.timestamp];
  }
  if (self.hasDirection) {
    [output writeEnum:4 value:self.direction];
  }
  if (self.hasSpeed) {
    [output writeInt32:5 value:self.speed];
  }
  if (self.hasAcceleration) {
    [output writeInt32:6 value:self.acceleration];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasSegment) {
    size += computeMessageSize(1, self.segment);
  }
  if (self.hasLocation) {
    size += computeMessageSize(2, self.location);
  }
  if (self.hasTimestamp) {
    size += computeInt64Size(3, self.timestamp);
  }
  if (self.hasDirection) {
    size += computeEnumSize(4, self.direction);
  }
  if (self.hasSpeed) {
    size += computeInt32Size(5, self.speed);
  }
  if (self.hasAcceleration) {
    size += computeInt32Size(6, self.acceleration);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSSTrafficProbe*) parseFromData:(NSData*) data {
  return (TSSTrafficProbe*)[[[TSSTrafficProbe builder] mergeFromData:data] build];
}
+ (TSSTrafficProbe*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSTrafficProbe*)[[[TSSTrafficProbe builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSSTrafficProbe*) parseFromInputStream:(NSInputStream*) input {
  return (TSSTrafficProbe*)[[[TSSTrafficProbe builder] mergeFromInputStream:input] build];
}
+ (TSSTrafficProbe*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSTrafficProbe*)[[[TSSTrafficProbe builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSTrafficProbe*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSSTrafficProbe*)[[[TSSTrafficProbe builder] mergeFromCodedInputStream:input] build];
}
+ (TSSTrafficProbe*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSTrafficProbe*)[[[TSSTrafficProbe builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSTrafficProbe_Builder*) builder {
  return [[[TSSTrafficProbe_Builder alloc] init] autorelease];
}
+ (TSSTrafficProbe_Builder*) builderWithPrototype:(TSSTrafficProbe*) prototype {
  return [[TSSTrafficProbe builder] mergeFrom:prototype];
}
- (TSSTrafficProbe_Builder*) builder {
  return [TSSTrafficProbe builder];
}
@end

@interface TSSTrafficProbe_Builder()
@property (retain) TSSTrafficProbe* result;
@end

@implementation TSSTrafficProbe_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSSTrafficProbe alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSSTrafficProbe_Builder*) clear {
  self.result = [[[TSSTrafficProbe alloc] init] autorelease];
  return self;
}
- (TSSTrafficProbe_Builder*) clone {
  return [TSSTrafficProbe builderWithPrototype:result];
}
- (TSSTrafficProbe*) defaultInstance {
  return [TSSTrafficProbe defaultInstance];
}
- (TSSTrafficProbe*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSSTrafficProbe*) buildPartial {
  TSSTrafficProbe* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSSTrafficProbe_Builder*) mergeFrom:(TSSTrafficProbe*) other {
  if (other == [TSSTrafficProbe defaultInstance]) {
    return self;
  }
  if (other.hasSegment) {
    [self mergeSegment:other.segment];
  }
  if (other.hasLocation) {
    [self mergeLocation:other.location];
  }
  if (other.hasTimestamp) {
    [self setTimestamp:other.timestamp];
  }
  if (other.hasDirection) {
    [self setDirection:other.direction];
  }
  if (other.hasSpeed) {
    [self setSpeed:other.speed];
  }
  if (other.hasAcceleration) {
    [self setAcceleration:other.acceleration];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSSTrafficProbe_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSSTrafficProbe_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        TSSSegment_Builder* subBuilder = [TSSSegment builder];
        if (self.hasSegment) {
          [subBuilder mergeFrom:self.segment];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setSegment:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        TSSCoordinate_Builder* subBuilder = [TSSCoordinate builder];
        if (self.hasLocation) {
          [subBuilder mergeFrom:self.location];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setLocation:[subBuilder buildPartial]];
        break;
      }
      case 24: {
        [self setTimestamp:[input readInt64]];
        break;
      }
      case 32: {
        int32_t value = [input readEnum];
        if (TSSDirectionIsValidValue(value)) {
          [self setDirection:value];
        } else {
          [unknownFields mergeVarintField:4 value:value];
        }
        break;
      }
      case 40: {
        [self setSpeed:[input readInt32]];
        break;
      }
      case 48: {
        [self setAcceleration:[input readInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasSegment {
  return result.hasSegment;
}
- (TSSSegment*) segment {
  return result.segment;
}
- (TSSTrafficProbe_Builder*) setSegment:(TSSSegment*) value {
  result.hasSegment = YES;
  result.segment = value;
  return self;
}
- (TSSTrafficProbe_Builder*) setSegmentBuilder:(TSSSegment_Builder*) builderForValue {
  return [self setSegment:[builderForValue build]];
}
- (TSSTrafficProbe_Builder*) mergeSegment:(TSSSegment*) value {
  if (result.hasSegment &&
      result.segment != [TSSSegment defaultInstance]) {
    result.segment =
      [[[TSSSegment builderWithPrototype:result.segment] mergeFrom:value] buildPartial];
  } else {
    result.segment = value;
  }
  result.hasSegment = YES;
  return self;
}
- (TSSTrafficProbe_Builder*) clearSegment {
  result.hasSegment = NO;
  result.segment = [TSSSegment defaultInstance];
  return self;
}
- (BOOL) hasLocation {
  return result.hasLocation;
}
- (TSSCoordinate*) location {
  return result.location;
}
- (TSSTrafficProbe_Builder*) setLocation:(TSSCoordinate*) value {
  result.hasLocation = YES;
  result.location = value;
  return self;
}
- (TSSTrafficProbe_Builder*) setLocationBuilder:(TSSCoordinate_Builder*) builderForValue {
  return [self setLocation:[builderForValue build]];
}
- (TSSTrafficProbe_Builder*) mergeLocation:(TSSCoordinate*) value {
  if (result.hasLocation &&
      result.location != [TSSCoordinate defaultInstance]) {
    result.location =
      [[[TSSCoordinate builderWithPrototype:result.location] mergeFrom:value] buildPartial];
  } else {
    result.location = value;
  }
  result.hasLocation = YES;
  return self;
}
- (TSSTrafficProbe_Builder*) clearLocation {
  result.hasLocation = NO;
  result.location = [TSSCoordinate defaultInstance];
  return self;
}
- (BOOL) hasTimestamp {
  return result.hasTimestamp;
}
- (int64_t) timestamp {
  return result.timestamp;
}
- (TSSTrafficProbe_Builder*) setTimestamp:(int64_t) value {
  result.hasTimestamp = YES;
  result.timestamp = value;
  return self;
}
- (TSSTrafficProbe_Builder*) clearTimestamp {
  result.hasTimestamp = NO;
  result.timestamp = 0L;
  return self;
}
- (BOOL) hasDirection {
  return result.hasDirection;
}
- (TSSDirection) direction {
  return result.direction;
}
- (TSSTrafficProbe_Builder*) setDirection:(TSSDirection) value {
  result.hasDirection = YES;
  result.direction = value;
  return self;
}
- (TSSTrafficProbe_Builder*) clearDirection {
  result.hasDirection = NO;
  result.direction = TSSDirectionUnknown;
  return self;
}
- (BOOL) hasSpeed {
  return result.hasSpeed;
}
- (int32_t) speed {
  return result.speed;
}
- (TSSTrafficProbe_Builder*) setSpeed:(int32_t) value {
  result.hasSpeed = YES;
  result.speed = value;
  return self;
}
- (TSSTrafficProbe_Builder*) clearSpeed {
  result.hasSpeed = NO;
  result.speed = 0;
  return self;
}
- (BOOL) hasAcceleration {
  return result.hasAcceleration;
}
- (int32_t) acceleration {
  return result.acceleration;
}
- (TSSTrafficProbe_Builder*) setAcceleration:(int32_t) value {
  result.hasAcceleration = YES;
  result.acceleration = value;
  return self;
}
- (TSSTrafficProbe_Builder*) clearAcceleration {
  result.hasAcceleration = NO;
  result.acceleration = 0;
  return self;
}
@end

@interface TSSSegmentTraffic ()
@property (retain) TSSSegment* segment;
@property int64_t timestamp;
@property TSSDirection direction;
@property int32_t speed;
@property (retain) NSString* details;
@end

@implementation TSSSegmentTraffic

- (BOOL) hasSegment {
  return !!hasSegment_;
}
- (void) setHasSegment:(BOOL) value {
  hasSegment_ = !!value;
}
@synthesize segment;
- (BOOL) hasTimestamp {
  return !!hasTimestamp_;
}
- (void) setHasTimestamp:(BOOL) value {
  hasTimestamp_ = !!value;
}
@synthesize timestamp;
- (BOOL) hasDirection {
  return !!hasDirection_;
}
- (void) setHasDirection:(BOOL) value {
  hasDirection_ = !!value;
}
@synthesize direction;
- (BOOL) hasSpeed {
  return !!hasSpeed_;
}
- (void) setHasSpeed:(BOOL) value {
  hasSpeed_ = !!value;
}
@synthesize speed;
- (BOOL) hasDetails {
  return !!hasDetails_;
}
- (void) setHasDetails:(BOOL) value {
  hasDetails_ = !!value;
}
@synthesize details;
- (void) dealloc {
  self.segment = nil;
  self.details = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.segment = [TSSSegment defaultInstance];
    self.timestamp = 0L;
    self.direction = TSSDirectionUnknown;
    self.speed = 0;
    self.details = @"";
  }
  return self;
}
static TSSSegmentTraffic* defaultTSSSegmentTrafficInstance = nil;
+ (void) initialize {
  if (self == [TSSSegmentTraffic class]) {
    defaultTSSSegmentTrafficInstance = [[TSSSegmentTraffic alloc] init];
  }
}
+ (TSSSegmentTraffic*) defaultInstance {
  return defaultTSSSegmentTrafficInstance;
}
- (TSSSegmentTraffic*) defaultInstance {
  return defaultTSSSegmentTrafficInstance;
}
- (BOOL) isInitialized {
  if (!self.hasSegment) {
    return NO;
  }
  if (!self.hasDirection) {
    return NO;
  }
  if (!self.hasSpeed) {
    return NO;
  }
  if (!self.segment.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasSegment) {
    [output writeMessage:1 value:self.segment];
  }
  if (self.hasTimestamp) {
    [output writeInt64:3 value:self.timestamp];
  }
  if (self.hasDirection) {
    [output writeEnum:4 value:self.direction];
  }
  if (self.hasSpeed) {
    [output writeInt32:5 value:self.speed];
  }
  if (self.hasDetails) {
    [output writeString:11 value:self.details];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasSegment) {
    size += computeMessageSize(1, self.segment);
  }
  if (self.hasTimestamp) {
    size += computeInt64Size(3, self.timestamp);
  }
  if (self.hasDirection) {
    size += computeEnumSize(4, self.direction);
  }
  if (self.hasSpeed) {
    size += computeInt32Size(5, self.speed);
  }
  if (self.hasDetails) {
    size += computeStringSize(11, self.details);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSSSegmentTraffic*) parseFromData:(NSData*) data {
  return (TSSSegmentTraffic*)[[[TSSSegmentTraffic builder] mergeFromData:data] build];
}
+ (TSSSegmentTraffic*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSSegmentTraffic*)[[[TSSSegmentTraffic builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSSSegmentTraffic*) parseFromInputStream:(NSInputStream*) input {
  return (TSSSegmentTraffic*)[[[TSSSegmentTraffic builder] mergeFromInputStream:input] build];
}
+ (TSSSegmentTraffic*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSSegmentTraffic*)[[[TSSSegmentTraffic builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSSegmentTraffic*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSSSegmentTraffic*)[[[TSSSegmentTraffic builder] mergeFromCodedInputStream:input] build];
}
+ (TSSSegmentTraffic*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSSegmentTraffic*)[[[TSSSegmentTraffic builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSSegmentTraffic_Builder*) builder {
  return [[[TSSSegmentTraffic_Builder alloc] init] autorelease];
}
+ (TSSSegmentTraffic_Builder*) builderWithPrototype:(TSSSegmentTraffic*) prototype {
  return [[TSSSegmentTraffic builder] mergeFrom:prototype];
}
- (TSSSegmentTraffic_Builder*) builder {
  return [TSSSegmentTraffic builder];
}
@end

@interface TSSSegmentTraffic_Builder()
@property (retain) TSSSegmentTraffic* result;
@end

@implementation TSSSegmentTraffic_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSSSegmentTraffic alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSSSegmentTraffic_Builder*) clear {
  self.result = [[[TSSSegmentTraffic alloc] init] autorelease];
  return self;
}
- (TSSSegmentTraffic_Builder*) clone {
  return [TSSSegmentTraffic builderWithPrototype:result];
}
- (TSSSegmentTraffic*) defaultInstance {
  return [TSSSegmentTraffic defaultInstance];
}
- (TSSSegmentTraffic*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSSSegmentTraffic*) buildPartial {
  TSSSegmentTraffic* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSSSegmentTraffic_Builder*) mergeFrom:(TSSSegmentTraffic*) other {
  if (other == [TSSSegmentTraffic defaultInstance]) {
    return self;
  }
  if (other.hasSegment) {
    [self mergeSegment:other.segment];
  }
  if (other.hasTimestamp) {
    [self setTimestamp:other.timestamp];
  }
  if (other.hasDirection) {
    [self setDirection:other.direction];
  }
  if (other.hasSpeed) {
    [self setSpeed:other.speed];
  }
  if (other.hasDetails) {
    [self setDetails:other.details];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSSSegmentTraffic_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSSSegmentTraffic_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        TSSSegment_Builder* subBuilder = [TSSSegment builder];
        if (self.hasSegment) {
          [subBuilder mergeFrom:self.segment];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setSegment:[subBuilder buildPartial]];
        break;
      }
      case 24: {
        [self setTimestamp:[input readInt64]];
        break;
      }
      case 32: {
        int32_t value = [input readEnum];
        if (TSSDirectionIsValidValue(value)) {
          [self setDirection:value];
        } else {
          [unknownFields mergeVarintField:4 value:value];
        }
        break;
      }
      case 40: {
        [self setSpeed:[input readInt32]];
        break;
      }
      case 90: {
        [self setDetails:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasSegment {
  return result.hasSegment;
}
- (TSSSegment*) segment {
  return result.segment;
}
- (TSSSegmentTraffic_Builder*) setSegment:(TSSSegment*) value {
  result.hasSegment = YES;
  result.segment = value;
  return self;
}
- (TSSSegmentTraffic_Builder*) setSegmentBuilder:(TSSSegment_Builder*) builderForValue {
  return [self setSegment:[builderForValue build]];
}
- (TSSSegmentTraffic_Builder*) mergeSegment:(TSSSegment*) value {
  if (result.hasSegment &&
      result.segment != [TSSSegment defaultInstance]) {
    result.segment =
      [[[TSSSegment builderWithPrototype:result.segment] mergeFrom:value] buildPartial];
  } else {
    result.segment = value;
  }
  result.hasSegment = YES;
  return self;
}
- (TSSSegmentTraffic_Builder*) clearSegment {
  result.hasSegment = NO;
  result.segment = [TSSSegment defaultInstance];
  return self;
}
- (BOOL) hasTimestamp {
  return result.hasTimestamp;
}
- (int64_t) timestamp {
  return result.timestamp;
}
- (TSSSegmentTraffic_Builder*) setTimestamp:(int64_t) value {
  result.hasTimestamp = YES;
  result.timestamp = value;
  return self;
}
- (TSSSegmentTraffic_Builder*) clearTimestamp {
  result.hasTimestamp = NO;
  result.timestamp = 0L;
  return self;
}
- (BOOL) hasDirection {
  return result.hasDirection;
}
- (TSSDirection) direction {
  return result.direction;
}
- (TSSSegmentTraffic_Builder*) setDirection:(TSSDirection) value {
  result.hasDirection = YES;
  result.direction = value;
  return self;
}
- (TSSSegmentTraffic_Builder*) clearDirection {
  result.hasDirection = NO;
  result.direction = TSSDirectionUnknown;
  return self;
}
- (BOOL) hasSpeed {
  return result.hasSpeed;
}
- (int32_t) speed {
  return result.speed;
}
- (TSSSegmentTraffic_Builder*) setSpeed:(int32_t) value {
  result.hasSpeed = YES;
  result.speed = value;
  return self;
}
- (TSSSegmentTraffic_Builder*) clearSpeed {
  result.hasSpeed = NO;
  result.speed = 0;
  return self;
}
- (BOOL) hasDetails {
  return result.hasDetails;
}
- (NSString*) details {
  return result.details;
}
- (TSSSegmentTraffic_Builder*) setDetails:(NSString*) value {
  result.hasDetails = YES;
  result.details = value;
  return self;
}
- (TSSSegmentTraffic_Builder*) clearDetails {
  result.hasDetails = NO;
  result.details = @"";
  return self;
}
@end

@interface TSSRoadTraffic ()
@property (retain) NSString* road;
@property int64_t timestamp;
@property (retain) NSMutableArray* mutableSegmentTrafficsList;
@property (retain) NSString* href;
@property (retain) NSString* desc;
@end

@implementation TSSRoadTraffic

- (BOOL) hasRoad {
  return !!hasRoad_;
}
- (void) setHasRoad:(BOOL) value {
  hasRoad_ = !!value;
}
@synthesize road;
- (BOOL) hasTimestamp {
  return !!hasTimestamp_;
}
- (void) setHasTimestamp:(BOOL) value {
  hasTimestamp_ = !!value;
}
@synthesize timestamp;
@synthesize mutableSegmentTrafficsList;
- (BOOL) hasHref {
  return !!hasHref_;
}
- (void) setHasHref:(BOOL) value {
  hasHref_ = !!value;
}
@synthesize href;
- (BOOL) hasDesc {
  return !!hasDesc_;
}
- (void) setHasDesc:(BOOL) value {
  hasDesc_ = !!value;
}
@synthesize desc;
- (void) dealloc {
  self.road = nil;
  self.mutableSegmentTrafficsList = nil;
  self.href = nil;
  self.desc = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.road = @"";
    self.timestamp = 0L;
    self.href = @"";
    self.desc = @"";
  }
  return self;
}
static TSSRoadTraffic* defaultTSSRoadTrafficInstance = nil;
+ (void) initialize {
  if (self == [TSSRoadTraffic class]) {
    defaultTSSRoadTrafficInstance = [[TSSRoadTraffic alloc] init];
  }
}
+ (TSSRoadTraffic*) defaultInstance {
  return defaultTSSRoadTrafficInstance;
}
- (TSSRoadTraffic*) defaultInstance {
  return defaultTSSRoadTrafficInstance;
}
- (NSArray*) segmentTrafficsList {
  return mutableSegmentTrafficsList;
}
- (TSSSegmentTraffic*) segmentTrafficsAtIndex:(int32_t) index {
  id value = [mutableSegmentTrafficsList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasRoad) {
    return NO;
  }
  for (TSSSegmentTraffic* element in self.segmentTrafficsList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasRoad) {
    [output writeString:1 value:self.road];
  }
  if (self.hasTimestamp) {
    [output writeInt64:2 value:self.timestamp];
  }
  for (TSSSegmentTraffic* element in self.segmentTrafficsList) {
    [output writeMessage:3 value:element];
  }
  if (self.hasDesc) {
    [output writeString:11 value:self.desc];
  }
  if (self.hasHref) {
    [output writeString:12 value:self.href];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasRoad) {
    size += computeStringSize(1, self.road);
  }
  if (self.hasTimestamp) {
    size += computeInt64Size(2, self.timestamp);
  }
  for (TSSSegmentTraffic* element in self.segmentTrafficsList) {
    size += computeMessageSize(3, element);
  }
  if (self.hasDesc) {
    size += computeStringSize(11, self.desc);
  }
  if (self.hasHref) {
    size += computeStringSize(12, self.href);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSSRoadTraffic*) parseFromData:(NSData*) data {
  return (TSSRoadTraffic*)[[[TSSRoadTraffic builder] mergeFromData:data] build];
}
+ (TSSRoadTraffic*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSRoadTraffic*)[[[TSSRoadTraffic builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSSRoadTraffic*) parseFromInputStream:(NSInputStream*) input {
  return (TSSRoadTraffic*)[[[TSSRoadTraffic builder] mergeFromInputStream:input] build];
}
+ (TSSRoadTraffic*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSRoadTraffic*)[[[TSSRoadTraffic builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSRoadTraffic*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSSRoadTraffic*)[[[TSSRoadTraffic builder] mergeFromCodedInputStream:input] build];
}
+ (TSSRoadTraffic*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSRoadTraffic*)[[[TSSRoadTraffic builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSRoadTraffic_Builder*) builder {
  return [[[TSSRoadTraffic_Builder alloc] init] autorelease];
}
+ (TSSRoadTraffic_Builder*) builderWithPrototype:(TSSRoadTraffic*) prototype {
  return [[TSSRoadTraffic builder] mergeFrom:prototype];
}
- (TSSRoadTraffic_Builder*) builder {
  return [TSSRoadTraffic builder];
}
@end

@interface TSSRoadTraffic_Builder()
@property (retain) TSSRoadTraffic* result;
@end

@implementation TSSRoadTraffic_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSSRoadTraffic alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSSRoadTraffic_Builder*) clear {
  self.result = [[[TSSRoadTraffic alloc] init] autorelease];
  return self;
}
- (TSSRoadTraffic_Builder*) clone {
  return [TSSRoadTraffic builderWithPrototype:result];
}
- (TSSRoadTraffic*) defaultInstance {
  return [TSSRoadTraffic defaultInstance];
}
- (TSSRoadTraffic*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSSRoadTraffic*) buildPartial {
  TSSRoadTraffic* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSSRoadTraffic_Builder*) mergeFrom:(TSSRoadTraffic*) other {
  if (other == [TSSRoadTraffic defaultInstance]) {
    return self;
  }
  if (other.hasRoad) {
    [self setRoad:other.road];
  }
  if (other.hasTimestamp) {
    [self setTimestamp:other.timestamp];
  }
  if (other.mutableSegmentTrafficsList.count > 0) {
    if (result.mutableSegmentTrafficsList == nil) {
      result.mutableSegmentTrafficsList = [NSMutableArray array];
    }
    [result.mutableSegmentTrafficsList addObjectsFromArray:other.mutableSegmentTrafficsList];
  }
  if (other.hasHref) {
    [self setHref:other.href];
  }
  if (other.hasDesc) {
    [self setDesc:other.desc];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSSRoadTraffic_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSSRoadTraffic_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setRoad:[input readString]];
        break;
      }
      case 16: {
        [self setTimestamp:[input readInt64]];
        break;
      }
      case 26: {
        TSSSegmentTraffic_Builder* subBuilder = [TSSSegmentTraffic builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addSegmentTraffics:[subBuilder buildPartial]];
        break;
      }
      case 90: {
        [self setDesc:[input readString]];
        break;
      }
      case 98: {
        [self setHref:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasRoad {
  return result.hasRoad;
}
- (NSString*) road {
  return result.road;
}
- (TSSRoadTraffic_Builder*) setRoad:(NSString*) value {
  result.hasRoad = YES;
  result.road = value;
  return self;
}
- (TSSRoadTraffic_Builder*) clearRoad {
  result.hasRoad = NO;
  result.road = @"";
  return self;
}
- (BOOL) hasTimestamp {
  return result.hasTimestamp;
}
- (int64_t) timestamp {
  return result.timestamp;
}
- (TSSRoadTraffic_Builder*) setTimestamp:(int64_t) value {
  result.hasTimestamp = YES;
  result.timestamp = value;
  return self;
}
- (TSSRoadTraffic_Builder*) clearTimestamp {
  result.hasTimestamp = NO;
  result.timestamp = 0L;
  return self;
}
- (NSArray*) segmentTrafficsList {
  if (result.mutableSegmentTrafficsList == nil) { return [NSArray array]; }
  return result.mutableSegmentTrafficsList;
}
- (TSSSegmentTraffic*) segmentTrafficsAtIndex:(int32_t) index {
  return [result segmentTrafficsAtIndex:index];
}
- (TSSRoadTraffic_Builder*) replaceSegmentTrafficsAtIndex:(int32_t) index with:(TSSSegmentTraffic*) value {
  [result.mutableSegmentTrafficsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (TSSRoadTraffic_Builder*) addAllSegmentTraffics:(NSArray*) values {
  if (result.mutableSegmentTrafficsList == nil) {
    result.mutableSegmentTrafficsList = [NSMutableArray array];
  }
  [result.mutableSegmentTrafficsList addObjectsFromArray:values];
  return self;
}
- (TSSRoadTraffic_Builder*) clearSegmentTrafficsList {
  result.mutableSegmentTrafficsList = nil;
  return self;
}
- (TSSRoadTraffic_Builder*) addSegmentTraffics:(TSSSegmentTraffic*) value {
  if (result.mutableSegmentTrafficsList == nil) {
    result.mutableSegmentTrafficsList = [NSMutableArray array];
  }
  [result.mutableSegmentTrafficsList addObject:value];
  return self;
}
- (BOOL) hasHref {
  return result.hasHref;
}
- (NSString*) href {
  return result.href;
}
- (TSSRoadTraffic_Builder*) setHref:(NSString*) value {
  result.hasHref = YES;
  result.href = value;
  return self;
}
- (TSSRoadTraffic_Builder*) clearHref {
  result.hasHref = NO;
  result.href = @"";
  return self;
}
- (BOOL) hasDesc {
  return result.hasDesc;
}
- (NSString*) desc {
  return result.desc;
}
- (TSSRoadTraffic_Builder*) setDesc:(NSString*) value {
  result.hasDesc = YES;
  result.desc = value;
  return self;
}
- (TSSRoadTraffic_Builder*) clearDesc {
  result.hasDesc = NO;
  result.desc = @"";
  return self;
}
@end

@interface TSSCityTraffic ()
@property (retain) NSString* city;
@property int64_t timestamp;
@property (retain) NSMutableArray* mutableRoadTrafficsList;
@end

@implementation TSSCityTraffic

- (BOOL) hasCity {
  return !!hasCity_;
}
- (void) setHasCity:(BOOL) value {
  hasCity_ = !!value;
}
@synthesize city;
- (BOOL) hasTimestamp {
  return !!hasTimestamp_;
}
- (void) setHasTimestamp:(BOOL) value {
  hasTimestamp_ = !!value;
}
@synthesize timestamp;
@synthesize mutableRoadTrafficsList;
- (void) dealloc {
  self.city = nil;
  self.mutableRoadTrafficsList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.city = @"";
    self.timestamp = 0L;
  }
  return self;
}
static TSSCityTraffic* defaultTSSCityTrafficInstance = nil;
+ (void) initialize {
  if (self == [TSSCityTraffic class]) {
    defaultTSSCityTrafficInstance = [[TSSCityTraffic alloc] init];
  }
}
+ (TSSCityTraffic*) defaultInstance {
  return defaultTSSCityTrafficInstance;
}
- (TSSCityTraffic*) defaultInstance {
  return defaultTSSCityTrafficInstance;
}
- (NSArray*) roadTrafficsList {
  return mutableRoadTrafficsList;
}
- (TSSRoadTraffic*) roadTrafficsAtIndex:(int32_t) index {
  id value = [mutableRoadTrafficsList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (TSSRoadTraffic* element in self.roadTrafficsList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasCity) {
    [output writeString:1 value:self.city];
  }
  if (self.hasTimestamp) {
    [output writeInt64:2 value:self.timestamp];
  }
  for (TSSRoadTraffic* element in self.roadTrafficsList) {
    [output writeMessage:3 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasCity) {
    size += computeStringSize(1, self.city);
  }
  if (self.hasTimestamp) {
    size += computeInt64Size(2, self.timestamp);
  }
  for (TSSRoadTraffic* element in self.roadTrafficsList) {
    size += computeMessageSize(3, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSSCityTraffic*) parseFromData:(NSData*) data {
  return (TSSCityTraffic*)[[[TSSCityTraffic builder] mergeFromData:data] build];
}
+ (TSSCityTraffic*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSCityTraffic*)[[[TSSCityTraffic builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSSCityTraffic*) parseFromInputStream:(NSInputStream*) input {
  return (TSSCityTraffic*)[[[TSSCityTraffic builder] mergeFromInputStream:input] build];
}
+ (TSSCityTraffic*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSCityTraffic*)[[[TSSCityTraffic builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSCityTraffic*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSSCityTraffic*)[[[TSSCityTraffic builder] mergeFromCodedInputStream:input] build];
}
+ (TSSCityTraffic*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSCityTraffic*)[[[TSSCityTraffic builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSCityTraffic_Builder*) builder {
  return [[[TSSCityTraffic_Builder alloc] init] autorelease];
}
+ (TSSCityTraffic_Builder*) builderWithPrototype:(TSSCityTraffic*) prototype {
  return [[TSSCityTraffic builder] mergeFrom:prototype];
}
- (TSSCityTraffic_Builder*) builder {
  return [TSSCityTraffic builder];
}
@end

@interface TSSCityTraffic_Builder()
@property (retain) TSSCityTraffic* result;
@end

@implementation TSSCityTraffic_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSSCityTraffic alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSSCityTraffic_Builder*) clear {
  self.result = [[[TSSCityTraffic alloc] init] autorelease];
  return self;
}
- (TSSCityTraffic_Builder*) clone {
  return [TSSCityTraffic builderWithPrototype:result];
}
- (TSSCityTraffic*) defaultInstance {
  return [TSSCityTraffic defaultInstance];
}
- (TSSCityTraffic*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSSCityTraffic*) buildPartial {
  TSSCityTraffic* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSSCityTraffic_Builder*) mergeFrom:(TSSCityTraffic*) other {
  if (other == [TSSCityTraffic defaultInstance]) {
    return self;
  }
  if (other.hasCity) {
    [self setCity:other.city];
  }
  if (other.hasTimestamp) {
    [self setTimestamp:other.timestamp];
  }
  if (other.mutableRoadTrafficsList.count > 0) {
    if (result.mutableRoadTrafficsList == nil) {
      result.mutableRoadTrafficsList = [NSMutableArray array];
    }
    [result.mutableRoadTrafficsList addObjectsFromArray:other.mutableRoadTrafficsList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSSCityTraffic_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSSCityTraffic_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setCity:[input readString]];
        break;
      }
      case 16: {
        [self setTimestamp:[input readInt64]];
        break;
      }
      case 26: {
        TSSRoadTraffic_Builder* subBuilder = [TSSRoadTraffic builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addRoadTraffics:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasCity {
  return result.hasCity;
}
- (NSString*) city {
  return result.city;
}
- (TSSCityTraffic_Builder*) setCity:(NSString*) value {
  result.hasCity = YES;
  result.city = value;
  return self;
}
- (TSSCityTraffic_Builder*) clearCity {
  result.hasCity = NO;
  result.city = @"";
  return self;
}
- (BOOL) hasTimestamp {
  return result.hasTimestamp;
}
- (int64_t) timestamp {
  return result.timestamp;
}
- (TSSCityTraffic_Builder*) setTimestamp:(int64_t) value {
  result.hasTimestamp = YES;
  result.timestamp = value;
  return self;
}
- (TSSCityTraffic_Builder*) clearTimestamp {
  result.hasTimestamp = NO;
  result.timestamp = 0L;
  return self;
}
- (NSArray*) roadTrafficsList {
  if (result.mutableRoadTrafficsList == nil) { return [NSArray array]; }
  return result.mutableRoadTrafficsList;
}
- (TSSRoadTraffic*) roadTrafficsAtIndex:(int32_t) index {
  return [result roadTrafficsAtIndex:index];
}
- (TSSCityTraffic_Builder*) replaceRoadTrafficsAtIndex:(int32_t) index with:(TSSRoadTraffic*) value {
  [result.mutableRoadTrafficsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (TSSCityTraffic_Builder*) addAllRoadTraffics:(NSArray*) values {
  if (result.mutableRoadTrafficsList == nil) {
    result.mutableRoadTrafficsList = [NSMutableArray array];
  }
  [result.mutableRoadTrafficsList addObjectsFromArray:values];
  return self;
}
- (TSSCityTraffic_Builder*) clearRoadTrafficsList {
  result.mutableRoadTrafficsList = nil;
  return self;
}
- (TSSCityTraffic_Builder*) addRoadTraffics:(TSSRoadTraffic*) value {
  if (result.mutableRoadTrafficsList == nil) {
    result.mutableRoadTrafficsList = [NSMutableArray array];
  }
  [result.mutableRoadTrafficsList addObject:value];
  return self;
}
@end

@interface TSSTrafficSub ()
@property (retain) NSString* city;
@property (retain) TSSRoute* route;
@property TSSOprType oprType;
@property TSSPubType pubType;
@property int32_t expires;
@end

@implementation TSSTrafficSub

- (BOOL) hasCity {
  return !!hasCity_;
}
- (void) setHasCity:(BOOL) value {
  hasCity_ = !!value;
}
@synthesize city;
- (BOOL) hasRoute {
  return !!hasRoute_;
}
- (void) setHasRoute:(BOOL) value {
  hasRoute_ = !!value;
}
@synthesize route;
- (BOOL) hasOprType {
  return !!hasOprType_;
}
- (void) setHasOprType:(BOOL) value {
  hasOprType_ = !!value;
}
@synthesize oprType;
- (BOOL) hasPubType {
  return !!hasPubType_;
}
- (void) setHasPubType:(BOOL) value {
  hasPubType_ = !!value;
}
@synthesize pubType;
- (BOOL) hasExpires {
  return !!hasExpires_;
}
- (void) setHasExpires:(BOOL) value {
  hasExpires_ = !!value;
}
@synthesize expires;
- (void) dealloc {
  self.city = nil;
  self.route = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.city = @"";
    self.route = [TSSRoute defaultInstance];
    self.oprType = TSSOprTypeSubCreate;
    self.pubType = TSSPubTypePubOnce;
    self.expires = 30;
  }
  return self;
}
static TSSTrafficSub* defaultTSSTrafficSubInstance = nil;
+ (void) initialize {
  if (self == [TSSTrafficSub class]) {
    defaultTSSTrafficSubInstance = [[TSSTrafficSub alloc] init];
  }
}
+ (TSSTrafficSub*) defaultInstance {
  return defaultTSSTrafficSubInstance;
}
- (TSSTrafficSub*) defaultInstance {
  return defaultTSSTrafficSubInstance;
}
- (BOOL) isInitialized {
  if (!self.hasCity) {
    return NO;
  }
  if (!self.hasRoute) {
    return NO;
  }
  if (!self.hasOprType) {
    return NO;
  }
  if (!self.hasPubType) {
    return NO;
  }
  if (!self.route.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasCity) {
    [output writeString:1 value:self.city];
  }
  if (self.hasRoute) {
    [output writeMessage:2 value:self.route];
  }
  if (self.hasOprType) {
    [output writeEnum:3 value:self.oprType];
  }
  if (self.hasPubType) {
    [output writeEnum:4 value:self.pubType];
  }
  if (self.hasExpires) {
    [output writeInt32:5 value:self.expires];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasCity) {
    size += computeStringSize(1, self.city);
  }
  if (self.hasRoute) {
    size += computeMessageSize(2, self.route);
  }
  if (self.hasOprType) {
    size += computeEnumSize(3, self.oprType);
  }
  if (self.hasPubType) {
    size += computeEnumSize(4, self.pubType);
  }
  if (self.hasExpires) {
    size += computeInt32Size(5, self.expires);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSSTrafficSub*) parseFromData:(NSData*) data {
  return (TSSTrafficSub*)[[[TSSTrafficSub builder] mergeFromData:data] build];
}
+ (TSSTrafficSub*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSTrafficSub*)[[[TSSTrafficSub builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSSTrafficSub*) parseFromInputStream:(NSInputStream*) input {
  return (TSSTrafficSub*)[[[TSSTrafficSub builder] mergeFromInputStream:input] build];
}
+ (TSSTrafficSub*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSTrafficSub*)[[[TSSTrafficSub builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSTrafficSub*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSSTrafficSub*)[[[TSSTrafficSub builder] mergeFromCodedInputStream:input] build];
}
+ (TSSTrafficSub*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSTrafficSub*)[[[TSSTrafficSub builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSTrafficSub_Builder*) builder {
  return [[[TSSTrafficSub_Builder alloc] init] autorelease];
}
+ (TSSTrafficSub_Builder*) builderWithPrototype:(TSSTrafficSub*) prototype {
  return [[TSSTrafficSub builder] mergeFrom:prototype];
}
- (TSSTrafficSub_Builder*) builder {
  return [TSSTrafficSub builder];
}
@end

@interface TSSTrafficSub_Builder()
@property (retain) TSSTrafficSub* result;
@end

@implementation TSSTrafficSub_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSSTrafficSub alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSSTrafficSub_Builder*) clear {
  self.result = [[[TSSTrafficSub alloc] init] autorelease];
  return self;
}
- (TSSTrafficSub_Builder*) clone {
  return [TSSTrafficSub builderWithPrototype:result];
}
- (TSSTrafficSub*) defaultInstance {
  return [TSSTrafficSub defaultInstance];
}
- (TSSTrafficSub*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSSTrafficSub*) buildPartial {
  TSSTrafficSub* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSSTrafficSub_Builder*) mergeFrom:(TSSTrafficSub*) other {
  if (other == [TSSTrafficSub defaultInstance]) {
    return self;
  }
  if (other.hasCity) {
    [self setCity:other.city];
  }
  if (other.hasRoute) {
    [self mergeRoute:other.route];
  }
  if (other.hasOprType) {
    [self setOprType:other.oprType];
  }
  if (other.hasPubType) {
    [self setPubType:other.pubType];
  }
  if (other.hasExpires) {
    [self setExpires:other.expires];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSSTrafficSub_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSSTrafficSub_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setCity:[input readString]];
        break;
      }
      case 18: {
        TSSRoute_Builder* subBuilder = [TSSRoute builder];
        if (self.hasRoute) {
          [subBuilder mergeFrom:self.route];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setRoute:[subBuilder buildPartial]];
        break;
      }
      case 24: {
        int32_t value = [input readEnum];
        if (TSSOprTypeIsValidValue(value)) {
          [self setOprType:value];
        } else {
          [unknownFields mergeVarintField:3 value:value];
        }
        break;
      }
      case 32: {
        int32_t value = [input readEnum];
        if (TSSPubTypeIsValidValue(value)) {
          [self setPubType:value];
        } else {
          [unknownFields mergeVarintField:4 value:value];
        }
        break;
      }
      case 40: {
        [self setExpires:[input readInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasCity {
  return result.hasCity;
}
- (NSString*) city {
  return result.city;
}
- (TSSTrafficSub_Builder*) setCity:(NSString*) value {
  result.hasCity = YES;
  result.city = value;
  return self;
}
- (TSSTrafficSub_Builder*) clearCity {
  result.hasCity = NO;
  result.city = @"";
  return self;
}
- (BOOL) hasRoute {
  return result.hasRoute;
}
- (TSSRoute*) route {
  return result.route;
}
- (TSSTrafficSub_Builder*) setRoute:(TSSRoute*) value {
  result.hasRoute = YES;
  result.route = value;
  return self;
}
- (TSSTrafficSub_Builder*) setRouteBuilder:(TSSRoute_Builder*) builderForValue {
  return [self setRoute:[builderForValue build]];
}
- (TSSTrafficSub_Builder*) mergeRoute:(TSSRoute*) value {
  if (result.hasRoute &&
      result.route != [TSSRoute defaultInstance]) {
    result.route =
      [[[TSSRoute builderWithPrototype:result.route] mergeFrom:value] buildPartial];
  } else {
    result.route = value;
  }
  result.hasRoute = YES;
  return self;
}
- (TSSTrafficSub_Builder*) clearRoute {
  result.hasRoute = NO;
  result.route = [TSSRoute defaultInstance];
  return self;
}
- (BOOL) hasOprType {
  return result.hasOprType;
}
- (TSSOprType) oprType {
  return result.oprType;
}
- (TSSTrafficSub_Builder*) setOprType:(TSSOprType) value {
  result.hasOprType = YES;
  result.oprType = value;
  return self;
}
- (TSSTrafficSub_Builder*) clearOprType {
  result.hasOprType = NO;
  result.oprType = TSSOprTypeSubCreate;
  return self;
}
- (BOOL) hasPubType {
  return result.hasPubType;
}
- (TSSPubType) pubType {
  return result.pubType;
}
- (TSSTrafficSub_Builder*) setPubType:(TSSPubType) value {
  result.hasPubType = YES;
  result.pubType = value;
  return self;
}
- (TSSTrafficSub_Builder*) clearPubType {
  result.hasPubType = NO;
  result.pubType = TSSPubTypePubOnce;
  return self;
}
- (BOOL) hasExpires {
  return result.hasExpires;
}
- (int32_t) expires {
  return result.expires;
}
- (TSSTrafficSub_Builder*) setExpires:(int32_t) value {
  result.hasExpires = YES;
  result.expires = value;
  return self;
}
- (TSSTrafficSub_Builder*) clearExpires {
  result.hasExpires = NO;
  result.expires = 30;
  return self;
}
@end

@interface TSSDeviceReport ()
@property (retain) NSString* deviceId;
@property (retain) NSData* deviceToken;
@property (retain) NSString* deviceName;
@property (retain) NSString* deviceModel;
@property (retain) NSString* deviceOsVersion;
@end

@implementation TSSDeviceReport

- (BOOL) hasDeviceId {
  return !!hasDeviceId_;
}
- (void) setHasDeviceId:(BOOL) value {
  hasDeviceId_ = !!value;
}
@synthesize deviceId;
- (BOOL) hasDeviceToken {
  return !!hasDeviceToken_;
}
- (void) setHasDeviceToken:(BOOL) value {
  hasDeviceToken_ = !!value;
}
@synthesize deviceToken;
- (BOOL) hasDeviceName {
  return !!hasDeviceName_;
}
- (void) setHasDeviceName:(BOOL) value {
  hasDeviceName_ = !!value;
}
@synthesize deviceName;
- (BOOL) hasDeviceModel {
  return !!hasDeviceModel_;
}
- (void) setHasDeviceModel:(BOOL) value {
  hasDeviceModel_ = !!value;
}
@synthesize deviceModel;
- (BOOL) hasDeviceOsVersion {
  return !!hasDeviceOsVersion_;
}
- (void) setHasDeviceOsVersion:(BOOL) value {
  hasDeviceOsVersion_ = !!value;
}
@synthesize deviceOsVersion;
- (void) dealloc {
  self.deviceId = nil;
  self.deviceToken = nil;
  self.deviceName = nil;
  self.deviceModel = nil;
  self.deviceOsVersion = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.deviceId = @"";
    self.deviceToken = [NSData data];
    self.deviceName = @"";
    self.deviceModel = @"";
    self.deviceOsVersion = @"";
  }
  return self;
}
static TSSDeviceReport* defaultTSSDeviceReportInstance = nil;
+ (void) initialize {
  if (self == [TSSDeviceReport class]) {
    defaultTSSDeviceReportInstance = [[TSSDeviceReport alloc] init];
  }
}
+ (TSSDeviceReport*) defaultInstance {
  return defaultTSSDeviceReportInstance;
}
- (TSSDeviceReport*) defaultInstance {
  return defaultTSSDeviceReportInstance;
}
- (BOOL) isInitialized {
  if (!self.hasDeviceId) {
    return NO;
  }
  if (!self.hasDeviceToken) {
    return NO;
  }
  if (!self.hasDeviceName) {
    return NO;
  }
  if (!self.hasDeviceModel) {
    return NO;
  }
  if (!self.hasDeviceOsVersion) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasDeviceId) {
    [output writeString:1 value:self.deviceId];
  }
  if (self.hasDeviceToken) {
    [output writeData:2 value:self.deviceToken];
  }
  if (self.hasDeviceName) {
    [output writeString:3 value:self.deviceName];
  }
  if (self.hasDeviceModel) {
    [output writeString:4 value:self.deviceModel];
  }
  if (self.hasDeviceOsVersion) {
    [output writeString:5 value:self.deviceOsVersion];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasDeviceId) {
    size += computeStringSize(1, self.deviceId);
  }
  if (self.hasDeviceToken) {
    size += computeDataSize(2, self.deviceToken);
  }
  if (self.hasDeviceName) {
    size += computeStringSize(3, self.deviceName);
  }
  if (self.hasDeviceModel) {
    size += computeStringSize(4, self.deviceModel);
  }
  if (self.hasDeviceOsVersion) {
    size += computeStringSize(5, self.deviceOsVersion);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSSDeviceReport*) parseFromData:(NSData*) data {
  return (TSSDeviceReport*)[[[TSSDeviceReport builder] mergeFromData:data] build];
}
+ (TSSDeviceReport*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSDeviceReport*)[[[TSSDeviceReport builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSSDeviceReport*) parseFromInputStream:(NSInputStream*) input {
  return (TSSDeviceReport*)[[[TSSDeviceReport builder] mergeFromInputStream:input] build];
}
+ (TSSDeviceReport*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSDeviceReport*)[[[TSSDeviceReport builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSDeviceReport*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSSDeviceReport*)[[[TSSDeviceReport builder] mergeFromCodedInputStream:input] build];
}
+ (TSSDeviceReport*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSDeviceReport*)[[[TSSDeviceReport builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSDeviceReport_Builder*) builder {
  return [[[TSSDeviceReport_Builder alloc] init] autorelease];
}
+ (TSSDeviceReport_Builder*) builderWithPrototype:(TSSDeviceReport*) prototype {
  return [[TSSDeviceReport builder] mergeFrom:prototype];
}
- (TSSDeviceReport_Builder*) builder {
  return [TSSDeviceReport builder];
}
@end

@interface TSSDeviceReport_Builder()
@property (retain) TSSDeviceReport* result;
@end

@implementation TSSDeviceReport_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSSDeviceReport alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSSDeviceReport_Builder*) clear {
  self.result = [[[TSSDeviceReport alloc] init] autorelease];
  return self;
}
- (TSSDeviceReport_Builder*) clone {
  return [TSSDeviceReport builderWithPrototype:result];
}
- (TSSDeviceReport*) defaultInstance {
  return [TSSDeviceReport defaultInstance];
}
- (TSSDeviceReport*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSSDeviceReport*) buildPartial {
  TSSDeviceReport* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSSDeviceReport_Builder*) mergeFrom:(TSSDeviceReport*) other {
  if (other == [TSSDeviceReport defaultInstance]) {
    return self;
  }
  if (other.hasDeviceId) {
    [self setDeviceId:other.deviceId];
  }
  if (other.hasDeviceToken) {
    [self setDeviceToken:other.deviceToken];
  }
  if (other.hasDeviceName) {
    [self setDeviceName:other.deviceName];
  }
  if (other.hasDeviceModel) {
    [self setDeviceModel:other.deviceModel];
  }
  if (other.hasDeviceOsVersion) {
    [self setDeviceOsVersion:other.deviceOsVersion];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSSDeviceReport_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSSDeviceReport_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setDeviceId:[input readString]];
        break;
      }
      case 18: {
        [self setDeviceToken:[input readData]];
        break;
      }
      case 26: {
        [self setDeviceName:[input readString]];
        break;
      }
      case 34: {
        [self setDeviceModel:[input readString]];
        break;
      }
      case 42: {
        [self setDeviceOsVersion:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasDeviceId {
  return result.hasDeviceId;
}
- (NSString*) deviceId {
  return result.deviceId;
}
- (TSSDeviceReport_Builder*) setDeviceId:(NSString*) value {
  result.hasDeviceId = YES;
  result.deviceId = value;
  return self;
}
- (TSSDeviceReport_Builder*) clearDeviceId {
  result.hasDeviceId = NO;
  result.deviceId = @"";
  return self;
}
- (BOOL) hasDeviceToken {
  return result.hasDeviceToken;
}
- (NSData*) deviceToken {
  return result.deviceToken;
}
- (TSSDeviceReport_Builder*) setDeviceToken:(NSData*) value {
  result.hasDeviceToken = YES;
  result.deviceToken = value;
  return self;
}
- (TSSDeviceReport_Builder*) clearDeviceToken {
  result.hasDeviceToken = NO;
  result.deviceToken = [NSData data];
  return self;
}
- (BOOL) hasDeviceName {
  return result.hasDeviceName;
}
- (NSString*) deviceName {
  return result.deviceName;
}
- (TSSDeviceReport_Builder*) setDeviceName:(NSString*) value {
  result.hasDeviceName = YES;
  result.deviceName = value;
  return self;
}
- (TSSDeviceReport_Builder*) clearDeviceName {
  result.hasDeviceName = NO;
  result.deviceName = @"";
  return self;
}
- (BOOL) hasDeviceModel {
  return result.hasDeviceModel;
}
- (NSString*) deviceModel {
  return result.deviceModel;
}
- (TSSDeviceReport_Builder*) setDeviceModel:(NSString*) value {
  result.hasDeviceModel = YES;
  result.deviceModel = value;
  return self;
}
- (TSSDeviceReport_Builder*) clearDeviceModel {
  result.hasDeviceModel = NO;
  result.deviceModel = @"";
  return self;
}
- (BOOL) hasDeviceOsVersion {
  return result.hasDeviceOsVersion;
}
- (NSString*) deviceOsVersion {
  return result.deviceOsVersion;
}
- (TSSDeviceReport_Builder*) setDeviceOsVersion:(NSString*) value {
  result.hasDeviceOsVersion = YES;
  result.deviceOsVersion = value;
  return self;
}
- (TSSDeviceReport_Builder*) clearDeviceOsVersion {
  result.hasDeviceOsVersion = NO;
  result.deviceOsVersion = @"";
  return self;
}
@end

@interface TSSPackage ()
@property int32_t version;
@property TSSMsgDir msgDir;
@property TSSMsgType msgType;
@property int32_t msgId;
@property int64_t timestamp;
@property int32_t expires;
@property (retain) NSData* userToken;
@property TSSErrCode errCode;
@property (retain) TSSDeviceReport* deviceReport;
@property (retain) TSSLocation* location;
@property (retain) TSSSegment* segment;
@property (retain) TSSRoute* route;
@property (retain) TSSTrafficSub* trafficSub;
@property (retain) TSSSegmentTraffic* segmentTraffic;
@property (retain) TSSRoadTraffic* roadTraffic;
@property (retain) TSSCityTraffic* cityTraffic;
@property (retain) TSSTrafficProbe* trafficProbe;
@end

@implementation TSSPackage

- (BOOL) hasVersion {
  return !!hasVersion_;
}
- (void) setHasVersion:(BOOL) value {
  hasVersion_ = !!value;
}
@synthesize version;
- (BOOL) hasMsgDir {
  return !!hasMsgDir_;
}
- (void) setHasMsgDir:(BOOL) value {
  hasMsgDir_ = !!value;
}
@synthesize msgDir;
- (BOOL) hasMsgType {
  return !!hasMsgType_;
}
- (void) setHasMsgType:(BOOL) value {
  hasMsgType_ = !!value;
}
@synthesize msgType;
- (BOOL) hasMsgId {
  return !!hasMsgId_;
}
- (void) setHasMsgId:(BOOL) value {
  hasMsgId_ = !!value;
}
@synthesize msgId;
- (BOOL) hasTimestamp {
  return !!hasTimestamp_;
}
- (void) setHasTimestamp:(BOOL) value {
  hasTimestamp_ = !!value;
}
@synthesize timestamp;
- (BOOL) hasExpires {
  return !!hasExpires_;
}
- (void) setHasExpires:(BOOL) value {
  hasExpires_ = !!value;
}
@synthesize expires;
- (BOOL) hasUserToken {
  return !!hasUserToken_;
}
- (void) setHasUserToken:(BOOL) value {
  hasUserToken_ = !!value;
}
@synthesize userToken;
- (BOOL) hasErrCode {
  return !!hasErrCode_;
}
- (void) setHasErrCode:(BOOL) value {
  hasErrCode_ = !!value;
}
@synthesize errCode;
- (BOOL) hasDeviceReport {
  return !!hasDeviceReport_;
}
- (void) setHasDeviceReport:(BOOL) value {
  hasDeviceReport_ = !!value;
}
@synthesize deviceReport;
- (BOOL) hasLocation {
  return !!hasLocation_;
}
- (void) setHasLocation:(BOOL) value {
  hasLocation_ = !!value;
}
@synthesize location;
- (BOOL) hasSegment {
  return !!hasSegment_;
}
- (void) setHasSegment:(BOOL) value {
  hasSegment_ = !!value;
}
@synthesize segment;
- (BOOL) hasRoute {
  return !!hasRoute_;
}
- (void) setHasRoute:(BOOL) value {
  hasRoute_ = !!value;
}
@synthesize route;
- (BOOL) hasTrafficSub {
  return !!hasTrafficSub_;
}
- (void) setHasTrafficSub:(BOOL) value {
  hasTrafficSub_ = !!value;
}
@synthesize trafficSub;
- (BOOL) hasSegmentTraffic {
  return !!hasSegmentTraffic_;
}
- (void) setHasSegmentTraffic:(BOOL) value {
  hasSegmentTraffic_ = !!value;
}
@synthesize segmentTraffic;
- (BOOL) hasRoadTraffic {
  return !!hasRoadTraffic_;
}
- (void) setHasRoadTraffic:(BOOL) value {
  hasRoadTraffic_ = !!value;
}
@synthesize roadTraffic;
- (BOOL) hasCityTraffic {
  return !!hasCityTraffic_;
}
- (void) setHasCityTraffic:(BOOL) value {
  hasCityTraffic_ = !!value;
}
@synthesize cityTraffic;
- (BOOL) hasTrafficProbe {
  return !!hasTrafficProbe_;
}
- (void) setHasTrafficProbe:(BOOL) value {
  hasTrafficProbe_ = !!value;
}
@synthesize trafficProbe;
- (void) dealloc {
  self.userToken = nil;
  self.deviceReport = nil;
  self.location = nil;
  self.segment = nil;
  self.route = nil;
  self.trafficSub = nil;
  self.segmentTraffic = nil;
  self.roadTraffic = nil;
  self.cityTraffic = nil;
  self.trafficProbe = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.version = 0;
    self.msgDir = TSSMsgDirClient2Tss;
    self.msgType = TSSMsgTypeVoid;
    self.msgId = 0;
    self.timestamp = 0L;
    self.expires = 30;
    self.userToken = [NSData data];
    self.errCode = TSSErrCodeVersionImcompatible;
    self.deviceReport = [TSSDeviceReport defaultInstance];
    self.location = [TSSLocation defaultInstance];
    self.segment = [TSSSegment defaultInstance];
    self.route = [TSSRoute defaultInstance];
    self.trafficSub = [TSSTrafficSub defaultInstance];
    self.segmentTraffic = [TSSSegmentTraffic defaultInstance];
    self.roadTraffic = [TSSRoadTraffic defaultInstance];
    self.cityTraffic = [TSSCityTraffic defaultInstance];
    self.trafficProbe = [TSSTrafficProbe defaultInstance];
  }
  return self;
}
static TSSPackage* defaultTSSPackageInstance = nil;
+ (void) initialize {
  if (self == [TSSPackage class]) {
    defaultTSSPackageInstance = [[TSSPackage alloc] init];
  }
}
+ (TSSPackage*) defaultInstance {
  return defaultTSSPackageInstance;
}
- (TSSPackage*) defaultInstance {
  return defaultTSSPackageInstance;
}
- (BOOL) isInitialized {
  if (!self.hasVersion) {
    return NO;
  }
  if (!self.hasMsgDir) {
    return NO;
  }
  if (!self.hasMsgType) {
    return NO;
  }
  if (!self.hasMsgId) {
    return NO;
  }
  if (!self.hasTimestamp) {
    return NO;
  }
  if (self.hasDeviceReport) {
    if (!self.deviceReport.isInitialized) {
      return NO;
    }
  }
  if (self.hasLocation) {
    if (!self.location.isInitialized) {
      return NO;
    }
  }
  if (self.hasSegment) {
    if (!self.segment.isInitialized) {
      return NO;
    }
  }
  if (self.hasRoute) {
    if (!self.route.isInitialized) {
      return NO;
    }
  }
  if (self.hasTrafficSub) {
    if (!self.trafficSub.isInitialized) {
      return NO;
    }
  }
  if (self.hasSegmentTraffic) {
    if (!self.segmentTraffic.isInitialized) {
      return NO;
    }
  }
  if (self.hasRoadTraffic) {
    if (!self.roadTraffic.isInitialized) {
      return NO;
    }
  }
  if (self.hasCityTraffic) {
    if (!self.cityTraffic.isInitialized) {
      return NO;
    }
  }
  if (self.hasTrafficProbe) {
    if (!self.trafficProbe.isInitialized) {
      return NO;
    }
  }
  if (!self.extensionsAreInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasVersion) {
    [output writeInt32:1 value:self.version];
  }
  if (self.hasMsgDir) {
    [output writeEnum:3 value:self.msgDir];
  }
  if (self.hasMsgType) {
    [output writeEnum:4 value:self.msgType];
  }
  if (self.hasMsgId) {
    [output writeInt32:5 value:self.msgId];
  }
  if (self.hasTimestamp) {
    [output writeInt64:6 value:self.timestamp];
  }
  if (self.hasExpires) {
    [output writeInt32:7 value:self.expires];
  }
  if (self.hasUserToken) {
    [output writeData:8 value:self.userToken];
  }
  if (self.hasErrCode) {
    [output writeEnum:17 value:self.errCode];
  }
  if (self.hasDeviceReport) {
    [output writeMessage:19 value:self.deviceReport];
  }
  if (self.hasLocation) {
    [output writeMessage:33 value:self.location];
  }
  if (self.hasSegment) {
    [output writeMessage:34 value:self.segment];
  }
  if (self.hasRoute) {
    [output writeMessage:35 value:self.route];
  }
  if (self.hasTrafficSub) {
    [output writeMessage:36 value:self.trafficSub];
  }
  if (self.hasSegmentTraffic) {
    [output writeMessage:49 value:self.segmentTraffic];
  }
  if (self.hasRoadTraffic) {
    [output writeMessage:50 value:self.roadTraffic];
  }
  if (self.hasCityTraffic) {
    [output writeMessage:51 value:self.cityTraffic];
  }
  if (self.hasTrafficProbe) {
    [output writeMessage:65 value:self.trafficProbe];
  }
  [self writeExtensionsToCodedOutputStream:output
                                      from:128
                                        to:256];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasVersion) {
    size += computeInt32Size(1, self.version);
  }
  if (self.hasMsgDir) {
    size += computeEnumSize(3, self.msgDir);
  }
  if (self.hasMsgType) {
    size += computeEnumSize(4, self.msgType);
  }
  if (self.hasMsgId) {
    size += computeInt32Size(5, self.msgId);
  }
  if (self.hasTimestamp) {
    size += computeInt64Size(6, self.timestamp);
  }
  if (self.hasExpires) {
    size += computeInt32Size(7, self.expires);
  }
  if (self.hasUserToken) {
    size += computeDataSize(8, self.userToken);
  }
  if (self.hasErrCode) {
    size += computeEnumSize(17, self.errCode);
  }
  if (self.hasDeviceReport) {
    size += computeMessageSize(19, self.deviceReport);
  }
  if (self.hasLocation) {
    size += computeMessageSize(33, self.location);
  }
  if (self.hasSegment) {
    size += computeMessageSize(34, self.segment);
  }
  if (self.hasRoute) {
    size += computeMessageSize(35, self.route);
  }
  if (self.hasTrafficSub) {
    size += computeMessageSize(36, self.trafficSub);
  }
  if (self.hasSegmentTraffic) {
    size += computeMessageSize(49, self.segmentTraffic);
  }
  if (self.hasRoadTraffic) {
    size += computeMessageSize(50, self.roadTraffic);
  }
  if (self.hasCityTraffic) {
    size += computeMessageSize(51, self.cityTraffic);
  }
  if (self.hasTrafficProbe) {
    size += computeMessageSize(65, self.trafficProbe);
  }
  size += [self extensionsSerializedSize];
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSSPackage*) parseFromData:(NSData*) data {
  return (TSSPackage*)[[[TSSPackage builder] mergeFromData:data] build];
}
+ (TSSPackage*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSPackage*)[[[TSSPackage builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSSPackage*) parseFromInputStream:(NSInputStream*) input {
  return (TSSPackage*)[[[TSSPackage builder] mergeFromInputStream:input] build];
}
+ (TSSPackage*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSPackage*)[[[TSSPackage builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSPackage*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSSPackage*)[[[TSSPackage builder] mergeFromCodedInputStream:input] build];
}
+ (TSSPackage*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSSPackage*)[[[TSSPackage builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSSPackage_Builder*) builder {
  return [[[TSSPackage_Builder alloc] init] autorelease];
}
+ (TSSPackage_Builder*) builderWithPrototype:(TSSPackage*) prototype {
  return [[TSSPackage builder] mergeFrom:prototype];
}
- (TSSPackage_Builder*) builder {
  return [TSSPackage builder];
}
@end

@interface TSSPackage_Builder()
@property (retain) TSSPackage* result;
@end

@implementation TSSPackage_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSSPackage alloc] init] autorelease];
  }
  return self;
}
- (PBExtendableMessage*) internalGetResult {
  return result;
}
- (TSSPackage_Builder*) clear {
  self.result = [[[TSSPackage alloc] init] autorelease];
  return self;
}
- (TSSPackage_Builder*) clone {
  return [TSSPackage builderWithPrototype:result];
}
- (TSSPackage*) defaultInstance {
  return [TSSPackage defaultInstance];
}
- (TSSPackage*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSSPackage*) buildPartial {
  TSSPackage* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSSPackage_Builder*) mergeFrom:(TSSPackage*) other {
  if (other == [TSSPackage defaultInstance]) {
    return self;
  }
  if (other.hasVersion) {
    [self setVersion:other.version];
  }
  if (other.hasMsgDir) {
    [self setMsgDir:other.msgDir];
  }
  if (other.hasMsgType) {
    [self setMsgType:other.msgType];
  }
  if (other.hasMsgId) {
    [self setMsgId:other.msgId];
  }
  if (other.hasTimestamp) {
    [self setTimestamp:other.timestamp];
  }
  if (other.hasExpires) {
    [self setExpires:other.expires];
  }
  if (other.hasUserToken) {
    [self setUserToken:other.userToken];
  }
  if (other.hasErrCode) {
    [self setErrCode:other.errCode];
  }
  if (other.hasDeviceReport) {
    [self mergeDeviceReport:other.deviceReport];
  }
  if (other.hasLocation) {
    [self mergeLocation:other.location];
  }
  if (other.hasSegment) {
    [self mergeSegment:other.segment];
  }
  if (other.hasRoute) {
    [self mergeRoute:other.route];
  }
  if (other.hasTrafficSub) {
    [self mergeTrafficSub:other.trafficSub];
  }
  if (other.hasSegmentTraffic) {
    [self mergeSegmentTraffic:other.segmentTraffic];
  }
  if (other.hasRoadTraffic) {
    [self mergeRoadTraffic:other.roadTraffic];
  }
  if (other.hasCityTraffic) {
    [self mergeCityTraffic:other.cityTraffic];
  }
  if (other.hasTrafficProbe) {
    [self mergeTrafficProbe:other.trafficProbe];
  }
  [self mergeExtensionFields:other];
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSSPackage_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSSPackage_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setVersion:[input readInt32]];
        break;
      }
      case 24: {
        int32_t value = [input readEnum];
        if (TSSMsgDirIsValidValue(value)) {
          [self setMsgDir:value];
        } else {
          [unknownFields mergeVarintField:3 value:value];
        }
        break;
      }
      case 32: {
        int32_t value = [input readEnum];
        if (TSSMsgTypeIsValidValue(value)) {
          [self setMsgType:value];
        } else {
          [unknownFields mergeVarintField:4 value:value];
        }
        break;
      }
      case 40: {
        [self setMsgId:[input readInt32]];
        break;
      }
      case 48: {
        [self setTimestamp:[input readInt64]];
        break;
      }
      case 56: {
        [self setExpires:[input readInt32]];
        break;
      }
      case 66: {
        [self setUserToken:[input readData]];
        break;
      }
      case 136: {
        int32_t value = [input readEnum];
        if (TSSErrCodeIsValidValue(value)) {
          [self setErrCode:value];
        } else {
          [unknownFields mergeVarintField:17 value:value];
        }
        break;
      }
      case 154: {
        TSSDeviceReport_Builder* subBuilder = [TSSDeviceReport builder];
        if (self.hasDeviceReport) {
          [subBuilder mergeFrom:self.deviceReport];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setDeviceReport:[subBuilder buildPartial]];
        break;
      }
      case 266: {
        TSSLocation_Builder* subBuilder = [TSSLocation builder];
        if (self.hasLocation) {
          [subBuilder mergeFrom:self.location];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setLocation:[subBuilder buildPartial]];
        break;
      }
      case 274: {
        TSSSegment_Builder* subBuilder = [TSSSegment builder];
        if (self.hasSegment) {
          [subBuilder mergeFrom:self.segment];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setSegment:[subBuilder buildPartial]];
        break;
      }
      case 282: {
        TSSRoute_Builder* subBuilder = [TSSRoute builder];
        if (self.hasRoute) {
          [subBuilder mergeFrom:self.route];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setRoute:[subBuilder buildPartial]];
        break;
      }
      case 290: {
        TSSTrafficSub_Builder* subBuilder = [TSSTrafficSub builder];
        if (self.hasTrafficSub) {
          [subBuilder mergeFrom:self.trafficSub];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setTrafficSub:[subBuilder buildPartial]];
        break;
      }
      case 394: {
        TSSSegmentTraffic_Builder* subBuilder = [TSSSegmentTraffic builder];
        if (self.hasSegmentTraffic) {
          [subBuilder mergeFrom:self.segmentTraffic];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setSegmentTraffic:[subBuilder buildPartial]];
        break;
      }
      case 402: {
        TSSRoadTraffic_Builder* subBuilder = [TSSRoadTraffic builder];
        if (self.hasRoadTraffic) {
          [subBuilder mergeFrom:self.roadTraffic];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setRoadTraffic:[subBuilder buildPartial]];
        break;
      }
      case 410: {
        TSSCityTraffic_Builder* subBuilder = [TSSCityTraffic builder];
        if (self.hasCityTraffic) {
          [subBuilder mergeFrom:self.cityTraffic];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setCityTraffic:[subBuilder buildPartial]];
        break;
      }
      case 522: {
        TSSTrafficProbe_Builder* subBuilder = [TSSTrafficProbe builder];
        if (self.hasTrafficProbe) {
          [subBuilder mergeFrom:self.trafficProbe];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setTrafficProbe:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasVersion {
  return result.hasVersion;
}
- (int32_t) version {
  return result.version;
}
- (TSSPackage_Builder*) setVersion:(int32_t) value {
  result.hasVersion = YES;
  result.version = value;
  return self;
}
- (TSSPackage_Builder*) clearVersion {
  result.hasVersion = NO;
  result.version = 0;
  return self;
}
- (BOOL) hasMsgDir {
  return result.hasMsgDir;
}
- (TSSMsgDir) msgDir {
  return result.msgDir;
}
- (TSSPackage_Builder*) setMsgDir:(TSSMsgDir) value {
  result.hasMsgDir = YES;
  result.msgDir = value;
  return self;
}
- (TSSPackage_Builder*) clearMsgDir {
  result.hasMsgDir = NO;
  result.msgDir = TSSMsgDirClient2Tss;
  return self;
}
- (BOOL) hasMsgType {
  return result.hasMsgType;
}
- (TSSMsgType) msgType {
  return result.msgType;
}
- (TSSPackage_Builder*) setMsgType:(TSSMsgType) value {
  result.hasMsgType = YES;
  result.msgType = value;
  return self;
}
- (TSSPackage_Builder*) clearMsgType {
  result.hasMsgType = NO;
  result.msgType = TSSMsgTypeVoid;
  return self;
}
- (BOOL) hasMsgId {
  return result.hasMsgId;
}
- (int32_t) msgId {
  return result.msgId;
}
- (TSSPackage_Builder*) setMsgId:(int32_t) value {
  result.hasMsgId = YES;
  result.msgId = value;
  return self;
}
- (TSSPackage_Builder*) clearMsgId {
  result.hasMsgId = NO;
  result.msgId = 0;
  return self;
}
- (BOOL) hasTimestamp {
  return result.hasTimestamp;
}
- (int64_t) timestamp {
  return result.timestamp;
}
- (TSSPackage_Builder*) setTimestamp:(int64_t) value {
  result.hasTimestamp = YES;
  result.timestamp = value;
  return self;
}
- (TSSPackage_Builder*) clearTimestamp {
  result.hasTimestamp = NO;
  result.timestamp = 0L;
  return self;
}
- (BOOL) hasExpires {
  return result.hasExpires;
}
- (int32_t) expires {
  return result.expires;
}
- (TSSPackage_Builder*) setExpires:(int32_t) value {
  result.hasExpires = YES;
  result.expires = value;
  return self;
}
- (TSSPackage_Builder*) clearExpires {
  result.hasExpires = NO;
  result.expires = 30;
  return self;
}
- (BOOL) hasUserToken {
  return result.hasUserToken;
}
- (NSData*) userToken {
  return result.userToken;
}
- (TSSPackage_Builder*) setUserToken:(NSData*) value {
  result.hasUserToken = YES;
  result.userToken = value;
  return self;
}
- (TSSPackage_Builder*) clearUserToken {
  result.hasUserToken = NO;
  result.userToken = [NSData data];
  return self;
}
- (BOOL) hasErrCode {
  return result.hasErrCode;
}
- (TSSErrCode) errCode {
  return result.errCode;
}
- (TSSPackage_Builder*) setErrCode:(TSSErrCode) value {
  result.hasErrCode = YES;
  result.errCode = value;
  return self;
}
- (TSSPackage_Builder*) clearErrCode {
  result.hasErrCode = NO;
  result.errCode = TSSErrCodeVersionImcompatible;
  return self;
}
- (BOOL) hasDeviceReport {
  return result.hasDeviceReport;
}
- (TSSDeviceReport*) deviceReport {
  return result.deviceReport;
}
- (TSSPackage_Builder*) setDeviceReport:(TSSDeviceReport*) value {
  result.hasDeviceReport = YES;
  result.deviceReport = value;
  return self;
}
- (TSSPackage_Builder*) setDeviceReportBuilder:(TSSDeviceReport_Builder*) builderForValue {
  return [self setDeviceReport:[builderForValue build]];
}
- (TSSPackage_Builder*) mergeDeviceReport:(TSSDeviceReport*) value {
  if (result.hasDeviceReport &&
      result.deviceReport != [TSSDeviceReport defaultInstance]) {
    result.deviceReport =
      [[[TSSDeviceReport builderWithPrototype:result.deviceReport] mergeFrom:value] buildPartial];
  } else {
    result.deviceReport = value;
  }
  result.hasDeviceReport = YES;
  return self;
}
- (TSSPackage_Builder*) clearDeviceReport {
  result.hasDeviceReport = NO;
  result.deviceReport = [TSSDeviceReport defaultInstance];
  return self;
}
- (BOOL) hasLocation {
  return result.hasLocation;
}
- (TSSLocation*) location {
  return result.location;
}
- (TSSPackage_Builder*) setLocation:(TSSLocation*) value {
  result.hasLocation = YES;
  result.location = value;
  return self;
}
- (TSSPackage_Builder*) setLocationBuilder:(TSSLocation_Builder*) builderForValue {
  return [self setLocation:[builderForValue build]];
}
- (TSSPackage_Builder*) mergeLocation:(TSSLocation*) value {
  if (result.hasLocation &&
      result.location != [TSSLocation defaultInstance]) {
    result.location =
      [[[TSSLocation builderWithPrototype:result.location] mergeFrom:value] buildPartial];
  } else {
    result.location = value;
  }
  result.hasLocation = YES;
  return self;
}
- (TSSPackage_Builder*) clearLocation {
  result.hasLocation = NO;
  result.location = [TSSLocation defaultInstance];
  return self;
}
- (BOOL) hasSegment {
  return result.hasSegment;
}
- (TSSSegment*) segment {
  return result.segment;
}
- (TSSPackage_Builder*) setSegment:(TSSSegment*) value {
  result.hasSegment = YES;
  result.segment = value;
  return self;
}
- (TSSPackage_Builder*) setSegmentBuilder:(TSSSegment_Builder*) builderForValue {
  return [self setSegment:[builderForValue build]];
}
- (TSSPackage_Builder*) mergeSegment:(TSSSegment*) value {
  if (result.hasSegment &&
      result.segment != [TSSSegment defaultInstance]) {
    result.segment =
      [[[TSSSegment builderWithPrototype:result.segment] mergeFrom:value] buildPartial];
  } else {
    result.segment = value;
  }
  result.hasSegment = YES;
  return self;
}
- (TSSPackage_Builder*) clearSegment {
  result.hasSegment = NO;
  result.segment = [TSSSegment defaultInstance];
  return self;
}
- (BOOL) hasRoute {
  return result.hasRoute;
}
- (TSSRoute*) route {
  return result.route;
}
- (TSSPackage_Builder*) setRoute:(TSSRoute*) value {
  result.hasRoute = YES;
  result.route = value;
  return self;
}
- (TSSPackage_Builder*) setRouteBuilder:(TSSRoute_Builder*) builderForValue {
  return [self setRoute:[builderForValue build]];
}
- (TSSPackage_Builder*) mergeRoute:(TSSRoute*) value {
  if (result.hasRoute &&
      result.route != [TSSRoute defaultInstance]) {
    result.route =
      [[[TSSRoute builderWithPrototype:result.route] mergeFrom:value] buildPartial];
  } else {
    result.route = value;
  }
  result.hasRoute = YES;
  return self;
}
- (TSSPackage_Builder*) clearRoute {
  result.hasRoute = NO;
  result.route = [TSSRoute defaultInstance];
  return self;
}
- (BOOL) hasTrafficSub {
  return result.hasTrafficSub;
}
- (TSSTrafficSub*) trafficSub {
  return result.trafficSub;
}
- (TSSPackage_Builder*) setTrafficSub:(TSSTrafficSub*) value {
  result.hasTrafficSub = YES;
  result.trafficSub = value;
  return self;
}
- (TSSPackage_Builder*) setTrafficSubBuilder:(TSSTrafficSub_Builder*) builderForValue {
  return [self setTrafficSub:[builderForValue build]];
}
- (TSSPackage_Builder*) mergeTrafficSub:(TSSTrafficSub*) value {
  if (result.hasTrafficSub &&
      result.trafficSub != [TSSTrafficSub defaultInstance]) {
    result.trafficSub =
      [[[TSSTrafficSub builderWithPrototype:result.trafficSub] mergeFrom:value] buildPartial];
  } else {
    result.trafficSub = value;
  }
  result.hasTrafficSub = YES;
  return self;
}
- (TSSPackage_Builder*) clearTrafficSub {
  result.hasTrafficSub = NO;
  result.trafficSub = [TSSTrafficSub defaultInstance];
  return self;
}
- (BOOL) hasSegmentTraffic {
  return result.hasSegmentTraffic;
}
- (TSSSegmentTraffic*) segmentTraffic {
  return result.segmentTraffic;
}
- (TSSPackage_Builder*) setSegmentTraffic:(TSSSegmentTraffic*) value {
  result.hasSegmentTraffic = YES;
  result.segmentTraffic = value;
  return self;
}
- (TSSPackage_Builder*) setSegmentTrafficBuilder:(TSSSegmentTraffic_Builder*) builderForValue {
  return [self setSegmentTraffic:[builderForValue build]];
}
- (TSSPackage_Builder*) mergeSegmentTraffic:(TSSSegmentTraffic*) value {
  if (result.hasSegmentTraffic &&
      result.segmentTraffic != [TSSSegmentTraffic defaultInstance]) {
    result.segmentTraffic =
      [[[TSSSegmentTraffic builderWithPrototype:result.segmentTraffic] mergeFrom:value] buildPartial];
  } else {
    result.segmentTraffic = value;
  }
  result.hasSegmentTraffic = YES;
  return self;
}
- (TSSPackage_Builder*) clearSegmentTraffic {
  result.hasSegmentTraffic = NO;
  result.segmentTraffic = [TSSSegmentTraffic defaultInstance];
  return self;
}
- (BOOL) hasRoadTraffic {
  return result.hasRoadTraffic;
}
- (TSSRoadTraffic*) roadTraffic {
  return result.roadTraffic;
}
- (TSSPackage_Builder*) setRoadTraffic:(TSSRoadTraffic*) value {
  result.hasRoadTraffic = YES;
  result.roadTraffic = value;
  return self;
}
- (TSSPackage_Builder*) setRoadTrafficBuilder:(TSSRoadTraffic_Builder*) builderForValue {
  return [self setRoadTraffic:[builderForValue build]];
}
- (TSSPackage_Builder*) mergeRoadTraffic:(TSSRoadTraffic*) value {
  if (result.hasRoadTraffic &&
      result.roadTraffic != [TSSRoadTraffic defaultInstance]) {
    result.roadTraffic =
      [[[TSSRoadTraffic builderWithPrototype:result.roadTraffic] mergeFrom:value] buildPartial];
  } else {
    result.roadTraffic = value;
  }
  result.hasRoadTraffic = YES;
  return self;
}
- (TSSPackage_Builder*) clearRoadTraffic {
  result.hasRoadTraffic = NO;
  result.roadTraffic = [TSSRoadTraffic defaultInstance];
  return self;
}
- (BOOL) hasCityTraffic {
  return result.hasCityTraffic;
}
- (TSSCityTraffic*) cityTraffic {
  return result.cityTraffic;
}
- (TSSPackage_Builder*) setCityTraffic:(TSSCityTraffic*) value {
  result.hasCityTraffic = YES;
  result.cityTraffic = value;
  return self;
}
- (TSSPackage_Builder*) setCityTrafficBuilder:(TSSCityTraffic_Builder*) builderForValue {
  return [self setCityTraffic:[builderForValue build]];
}
- (TSSPackage_Builder*) mergeCityTraffic:(TSSCityTraffic*) value {
  if (result.hasCityTraffic &&
      result.cityTraffic != [TSSCityTraffic defaultInstance]) {
    result.cityTraffic =
      [[[TSSCityTraffic builderWithPrototype:result.cityTraffic] mergeFrom:value] buildPartial];
  } else {
    result.cityTraffic = value;
  }
  result.hasCityTraffic = YES;
  return self;
}
- (TSSPackage_Builder*) clearCityTraffic {
  result.hasCityTraffic = NO;
  result.cityTraffic = [TSSCityTraffic defaultInstance];
  return self;
}
- (BOOL) hasTrafficProbe {
  return result.hasTrafficProbe;
}
- (TSSTrafficProbe*) trafficProbe {
  return result.trafficProbe;
}
- (TSSPackage_Builder*) setTrafficProbe:(TSSTrafficProbe*) value {
  result.hasTrafficProbe = YES;
  result.trafficProbe = value;
  return self;
}
- (TSSPackage_Builder*) setTrafficProbeBuilder:(TSSTrafficProbe_Builder*) builderForValue {
  return [self setTrafficProbe:[builderForValue build]];
}
- (TSSPackage_Builder*) mergeTrafficProbe:(TSSTrafficProbe*) value {
  if (result.hasTrafficProbe &&
      result.trafficProbe != [TSSTrafficProbe defaultInstance]) {
    result.trafficProbe =
      [[[TSSTrafficProbe builderWithPrototype:result.trafficProbe] mergeFrom:value] buildPartial];
  } else {
    result.trafficProbe = value;
  }
  result.hasTrafficProbe = YES;
  return self;
}
- (TSSPackage_Builder*) clearTrafficProbe {
  result.hasTrafficProbe = NO;
  result.trafficProbe = [TSSTrafficProbe defaultInstance];
  return self;
}
@end

