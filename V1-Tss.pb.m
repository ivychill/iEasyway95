// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "Tss.pb.h"

@implementation TssRoot
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [TssRoot class]) {
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    extensionRegistry = [registry retain];
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
}
@end

@interface TSS_Point ()
@property Float64 lon;
@property Float64 lat;
@end

@implementation TSS_Point

- (BOOL) hasLon {
  return !!hasLon_;
}
- (void) setHasLon:(BOOL) value {
  hasLon_ = !!value;
}
@synthesize lon;
- (BOOL) hasLat {
  return !!hasLat_;
}
- (void) setHasLat:(BOOL) value {
  hasLat_ = !!value;
}
@synthesize lat;
- (void) dealloc {
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.lon = 0;
    self.lat = 0;
  }
  return self;
}
static TSS_Point* defaultTSS_PointInstance = nil;
+ (void) initialize {
  if (self == [TSS_Point class]) {
    defaultTSS_PointInstance = [[TSS_Point alloc] init];
  }
}
+ (TSS_Point*) defaultInstance {
  return defaultTSS_PointInstance;
}
- (TSS_Point*) defaultInstance {
  return defaultTSS_PointInstance;
}
- (BOOL) isInitialized {
  if (!self.hasLon) {
      NSLog(@"[Reason: TSS_Point NO_Lon]");
    return NO;
  }
  if (!self.hasLat) {
      NSLog(@"[Reason: TSS_Point NO_Lat]");
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasLon) {
    [output writeDouble:1 value:self.lon];
  }
  if (self.hasLat) {
    [output writeDouble:2 value:self.lat];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasLon) {
    size += computeDoubleSize(1, self.lon);
  }
  if (self.hasLat) {
    size += computeDoubleSize(2, self.lat);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSS_Point*) parseFromData:(NSData*) data {
  return (TSS_Point*)[[[TSS_Point builder] mergeFromData:data] build];
}
+ (TSS_Point*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_Point*)[[[TSS_Point builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSS_Point*) parseFromInputStream:(NSInputStream*) input {
  return (TSS_Point*)[[[TSS_Point builder] mergeFromInputStream:input] build];
}
+ (TSS_Point*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_Point*)[[[TSS_Point builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_Point*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSS_Point*)[[[TSS_Point builder] mergeFromCodedInputStream:input] build];
}
+ (TSS_Point*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_Point*)[[[TSS_Point builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_Point_Builder*) builder {
  return [[[TSS_Point_Builder alloc] init] autorelease];
}
+ (TSS_Point_Builder*) builderWithPrototype:(TSS_Point*) prototype {
  return [[TSS_Point builder] mergeFrom:prototype];
}
- (TSS_Point_Builder*) builder {
  return [TSS_Point builder];
}
@end

@interface TSS_Point_Builder()
@property (retain) TSS_Point* result;
@end

@implementation TSS_Point_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSS_Point alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSS_Point_Builder*) clear {
  self.result = [[[TSS_Point alloc] init] autorelease];
  return self;
}
- (TSS_Point_Builder*) clone {
  return [TSS_Point builderWithPrototype:result];
}
- (TSS_Point*) defaultInstance {
  return [TSS_Point defaultInstance];
}
- (TSS_Point*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSS_Point*) buildPartial {
  TSS_Point* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSS_Point_Builder*) mergeFrom:(TSS_Point*) other {
  if (other == [TSS_Point defaultInstance]) {
    return self;
  }
  if (other.hasLon) {
    [self setLon:other.lon];
  }
  if (other.hasLat) {
    [self setLat:other.lat];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSS_Point_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSS_Point_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 9: {
        [self setLon:[input readDouble]];
        break;
      }
      case 17: {
        [self setLat:[input readDouble]];
        break;
      }
    }
  }
}
- (BOOL) hasLon {
  return result.hasLon;
}
- (Float64) lon {
  return result.lon;
}
- (TSS_Point_Builder*) setLon:(Float64) value {
  result.hasLon = YES;
  result.lon = value;
  return self;
}
- (TSS_Point_Builder*) clearLon {
  result.hasLon = NO;
  result.lon = 0;
  return self;
}
- (BOOL) hasLat {
  return result.hasLat;
}
- (Float64) lat {
  return result.lat;
}
- (TSS_Point_Builder*) setLat:(Float64) value {
  result.hasLat = YES;
  result.lat = value;
  return self;
}
- (TSS_Point_Builder*) clearLat {
  result.hasLat = NO;
  result.lat = 0;
  return self;
}
@end

@interface TSS_Line ()
@property (retain) TSS_Point* start;
@property (retain) TSS_Point* end;
@end

@implementation TSS_Line

- (BOOL) hasStart {
  return !!hasStart_;
}
- (void) setHasStart:(BOOL) value {
  hasStart_ = !!value;
}
@synthesize start;
- (BOOL) hasEnd {
  return !!hasEnd_;
}
- (void) setHasEnd:(BOOL) value {
  hasEnd_ = !!value;
}
@synthesize end;
- (void) dealloc {
  self.start = nil;
  self.end = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.start = [TSS_Point defaultInstance];
    self.end = [TSS_Point defaultInstance];
  }
  return self;
}
static TSS_Line* defaultTSS_LineInstance = nil;
+ (void) initialize {
  if (self == [TSS_Line class]) {
    defaultTSS_LineInstance = [[TSS_Line alloc] init];
  }
}
+ (TSS_Line*) defaultInstance {
  return defaultTSS_LineInstance;
}
- (TSS_Line*) defaultInstance {
  return defaultTSS_LineInstance;
}
- (BOOL) isInitialized {
  if (!self.hasStart) {
      NSLog(@"[Reason: TSSLine NO Start]");
    return NO;
  }
  if (!self.hasEnd) {
      NSLog(@"[Reason: TSSLine NO End]");
    return NO;
  }
  if (!self.start.isInitialized) {
      NSLog(@"[Reason: TSSLine start_no_initial]");
    return NO;
  }
  if (!self.end.isInitialized) {
      NSLog(@"[Reason: TSSLine end_no_initial]");
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasStart) {
    [output writeMessage:1 value:self.start];
  }
  if (self.hasEnd) {
    [output writeMessage:2 value:self.end];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasStart) {
    size += computeMessageSize(1, self.start);
  }
  if (self.hasEnd) {
    size += computeMessageSize(2, self.end);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSS_Line*) parseFromData:(NSData*) data {
  return (TSS_Line*)[[[TSS_Line builder] mergeFromData:data] build];
}
+ (TSS_Line*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_Line*)[[[TSS_Line builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSS_Line*) parseFromInputStream:(NSInputStream*) input {
  return (TSS_Line*)[[[TSS_Line builder] mergeFromInputStream:input] build];
}
+ (TSS_Line*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_Line*)[[[TSS_Line builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_Line*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSS_Line*)[[[TSS_Line builder] mergeFromCodedInputStream:input] build];
}
+ (TSS_Line*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_Line*)[[[TSS_Line builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_Line_Builder*) builder {
  return [[[TSS_Line_Builder alloc] init] autorelease];
}
+ (TSS_Line_Builder*) builderWithPrototype:(TSS_Line*) prototype {
  return [[TSS_Line builder] mergeFrom:prototype];
}
- (TSS_Line_Builder*) builder {
  return [TSS_Line builder];
}
@end

@interface TSS_Line_Builder()
@property (retain) TSS_Line* result;
@end

@implementation TSS_Line_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSS_Line alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSS_Line_Builder*) clear {
  self.result = [[[TSS_Line alloc] init] autorelease];
  return self;
}
- (TSS_Line_Builder*) clone {
  return [TSS_Line builderWithPrototype:result];
}
- (TSS_Line*) defaultInstance {
  return [TSS_Line defaultInstance];
}
- (TSS_Line*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSS_Line*) buildPartial {
  TSS_Line* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSS_Line_Builder*) mergeFrom:(TSS_Line*) other {
  if (other == [TSS_Line defaultInstance]) {
    return self;
  }
  if (other.hasStart) {
    [self mergeStart:other.start];
  }
  if (other.hasEnd) {
    [self mergeEnd:other.end];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSS_Line_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSS_Line_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        TSS_Point_Builder* subBuilder = [TSS_Point builder];
        if (self.hasStart) {
          [subBuilder mergeFrom:self.start];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setStart:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        TSS_Point_Builder* subBuilder = [TSS_Point builder];
        if (self.hasEnd) {
          [subBuilder mergeFrom:self.end];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setEnd:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasStart {
  return result.hasStart;
}
- (TSS_Point*) start {
  return result.start;
}
- (TSS_Line_Builder*) setStart:(TSS_Point*) value {
  result.hasStart = YES;
  result.start = value;
  return self;
}
- (TSS_Line_Builder*) setStartBuilder:(TSS_Point_Builder*) builderForValue {
  return [self setStart:[builderForValue build]];
}
- (TSS_Line_Builder*) mergeStart:(TSS_Point*) value {
  if (result.hasStart &&
      result.start != [TSS_Point defaultInstance]) {
    result.start =
      [[[TSS_Point builderWithPrototype:result.start] mergeFrom:value] buildPartial];
  } else {
    result.start = value;
  }
  result.hasStart = YES;
  return self;
}
- (TSS_Line_Builder*) clearStart {
  result.hasStart = NO;
  result.start = [TSS_Point defaultInstance];
  return self;
}
- (BOOL) hasEnd {
  return result.hasEnd;
}
- (TSS_Point*) end {
  return result.end;
}
- (TSS_Line_Builder*) setEnd:(TSS_Point*) value {
  result.hasEnd = YES;
  result.end = value;
  return self;
}
- (TSS_Line_Builder*) setEndBuilder:(TSS_Point_Builder*) builderForValue {
  return [self setEnd:[builderForValue build]];
}
- (TSS_Line_Builder*) mergeEnd:(TSS_Point*) value {
  if (result.hasEnd &&
      result.end != [TSS_Point defaultInstance]) {
    result.end =
      [[[TSS_Point builderWithPrototype:result.end] mergeFrom:value] buildPartial];
  } else {
    result.end = value;
  }
  result.hasEnd = YES;
  return self;
}
- (TSS_Line_Builder*) clearEnd {
  result.hasEnd = NO;
  result.end = [TSS_Point defaultInstance];
  return self;
}
@end

@interface TSS_DrivingRoute ()
@property (retain) TSS_Point* start;
@property (retain) NSMutableArray* mutableSegmentList;
@end

@implementation TSS_DrivingRoute

- (BOOL) hasStart {
  return !!hasStart_;
}
- (void) setHasStart:(BOOL) value {
  hasStart_ = !!value;
}
@synthesize start;
@synthesize mutableSegmentList;
- (void) dealloc {
  self.start = nil;
  self.mutableSegmentList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.start = [TSS_Point defaultInstance];
  }
  return self;
}
static TSS_DrivingRoute* defaultTSS_DrivingRouteInstance = nil;
+ (void) initialize {
  if (self == [TSS_DrivingRoute class]) {
    defaultTSS_DrivingRouteInstance = [[TSS_DrivingRoute alloc] init];
  }
}
+ (TSS_DrivingRoute*) defaultInstance {
  return defaultTSS_DrivingRouteInstance;
}
- (TSS_DrivingRoute*) defaultInstance {
  return defaultTSS_DrivingRouteInstance;
}
- (NSArray*) segmentList {
  return mutableSegmentList;
}
- (TSS_DrivingRoute_RoadAndPoint*) segmentAtIndex:(int32_t) index {
  id value = [mutableSegmentList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasStart) {
      NSLog(@"[Reason: TSSDrivingRoute NO Start]");
    return NO;
  }
  if (!self.start.isInitialized) {
      NSLog(@"[Reason: TSSDrivingRoute start no init]");
    return NO;
  }
  for (TSS_DrivingRoute_RoadAndPoint* element in self.segmentList) {
    if (!element.isInitialized) {
        NSLog(@"[Reason: TSSDrivingRoute element no init]");
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasStart) {
    [output writeMessage:1 value:self.start];
  }
  for (TSS_DrivingRoute_RoadAndPoint* element in self.segmentList) {
    [output writeMessage:2 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasStart) {
    size += computeMessageSize(1, self.start);
  }
  for (TSS_DrivingRoute_RoadAndPoint* element in self.segmentList) {
    size += computeMessageSize(2, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSS_DrivingRoute*) parseFromData:(NSData*) data {
  return (TSS_DrivingRoute*)[[[TSS_DrivingRoute builder] mergeFromData:data] build];
}
+ (TSS_DrivingRoute*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_DrivingRoute*)[[[TSS_DrivingRoute builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSS_DrivingRoute*) parseFromInputStream:(NSInputStream*) input {
  return (TSS_DrivingRoute*)[[[TSS_DrivingRoute builder] mergeFromInputStream:input] build];
}
+ (TSS_DrivingRoute*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_DrivingRoute*)[[[TSS_DrivingRoute builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_DrivingRoute*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSS_DrivingRoute*)[[[TSS_DrivingRoute builder] mergeFromCodedInputStream:input] build];
}
+ (TSS_DrivingRoute*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_DrivingRoute*)[[[TSS_DrivingRoute builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_DrivingRoute_Builder*) builder {
  return [[[TSS_DrivingRoute_Builder alloc] init] autorelease];
}
+ (TSS_DrivingRoute_Builder*) builderWithPrototype:(TSS_DrivingRoute*) prototype {
  return [[TSS_DrivingRoute builder] mergeFrom:prototype];
}
- (TSS_DrivingRoute_Builder*) builder {
  return [TSS_DrivingRoute builder];
}
@end

@interface TSS_DrivingRoute_RoadAndPoint ()
@property (retain) NSString* road;
@property (retain) TSS_Point* end;
@end

@implementation TSS_DrivingRoute_RoadAndPoint

- (BOOL) hasRoad {
  return !!hasRoad_;
}
- (void) setHasRoad:(BOOL) value {
  hasRoad_ = !!value;
}
@synthesize road;
- (BOOL) hasEnd {
  return !!hasEnd_;
}
- (void) setHasEnd:(BOOL) value {
  hasEnd_ = !!value;
}
@synthesize end;
- (void) dealloc {
  self.road = nil;
  self.end = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.road = @"";
    self.end = [TSS_Point defaultInstance];
  }
  return self;
}
static TSS_DrivingRoute_RoadAndPoint* defaultTSS_DrivingRoute_RoadAndPointInstance = nil;
+ (void) initialize {
  if (self == [TSS_DrivingRoute_RoadAndPoint class]) {
    defaultTSS_DrivingRoute_RoadAndPointInstance = [[TSS_DrivingRoute_RoadAndPoint alloc] init];
  }
}
+ (TSS_DrivingRoute_RoadAndPoint*) defaultInstance {
  return defaultTSS_DrivingRoute_RoadAndPointInstance;
}
- (TSS_DrivingRoute_RoadAndPoint*) defaultInstance {
  return defaultTSS_DrivingRoute_RoadAndPointInstance;
}
- (BOOL) isInitialized {
  if (!self.hasRoad) {
      NSLog(@"[Reason: TSS_DrivingRoute_RoadAndPoint NO Road]");
    return NO;
  }
  if (!self.hasEnd) {
      NSLog(@"[Reason: TSS_DrivingRoute_RoadAndPoint NO End]");
    return NO;
  }
  if (!self.end.isInitialized) {
      NSLog(@"[Reason: TSS_DrivingRoute_RoadAndPoint NO end init]");
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasRoad) {
    [output writeString:1 value:self.road];
  }
  if (self.hasEnd) {
    [output writeMessage:2 value:self.end];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasRoad) {
    size += computeStringSize(1, self.road);
  }
  if (self.hasEnd) {
    size += computeMessageSize(2, self.end);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSS_DrivingRoute_RoadAndPoint*) parseFromData:(NSData*) data {
  return (TSS_DrivingRoute_RoadAndPoint*)[[[TSS_DrivingRoute_RoadAndPoint builder] mergeFromData:data] build];
}
+ (TSS_DrivingRoute_RoadAndPoint*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_DrivingRoute_RoadAndPoint*)[[[TSS_DrivingRoute_RoadAndPoint builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSS_DrivingRoute_RoadAndPoint*) parseFromInputStream:(NSInputStream*) input {
  return (TSS_DrivingRoute_RoadAndPoint*)[[[TSS_DrivingRoute_RoadAndPoint builder] mergeFromInputStream:input] build];
}
+ (TSS_DrivingRoute_RoadAndPoint*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_DrivingRoute_RoadAndPoint*)[[[TSS_DrivingRoute_RoadAndPoint builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_DrivingRoute_RoadAndPoint*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSS_DrivingRoute_RoadAndPoint*)[[[TSS_DrivingRoute_RoadAndPoint builder] mergeFromCodedInputStream:input] build];
}
+ (TSS_DrivingRoute_RoadAndPoint*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_DrivingRoute_RoadAndPoint*)[[[TSS_DrivingRoute_RoadAndPoint builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_DrivingRoute_RoadAndPoint_Builder*) builder {
  return [[[TSS_DrivingRoute_RoadAndPoint_Builder alloc] init] autorelease];
}
+ (TSS_DrivingRoute_RoadAndPoint_Builder*) builderWithPrototype:(TSS_DrivingRoute_RoadAndPoint*) prototype {
  return [[TSS_DrivingRoute_RoadAndPoint builder] mergeFrom:prototype];
}
- (TSS_DrivingRoute_RoadAndPoint_Builder*) builder {
  return [TSS_DrivingRoute_RoadAndPoint builder];
}
@end

@interface TSS_DrivingRoute_RoadAndPoint_Builder()
@property (retain) TSS_DrivingRoute_RoadAndPoint* result;
@end

@implementation TSS_DrivingRoute_RoadAndPoint_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSS_DrivingRoute_RoadAndPoint alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSS_DrivingRoute_RoadAndPoint_Builder*) clear {
  self.result = [[[TSS_DrivingRoute_RoadAndPoint alloc] init] autorelease];
  return self;
}
- (TSS_DrivingRoute_RoadAndPoint_Builder*) clone {
  return [TSS_DrivingRoute_RoadAndPoint builderWithPrototype:result];
}
- (TSS_DrivingRoute_RoadAndPoint*) defaultInstance {
  return [TSS_DrivingRoute_RoadAndPoint defaultInstance];
}
- (TSS_DrivingRoute_RoadAndPoint*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSS_DrivingRoute_RoadAndPoint*) buildPartial {
  TSS_DrivingRoute_RoadAndPoint* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSS_DrivingRoute_RoadAndPoint_Builder*) mergeFrom:(TSS_DrivingRoute_RoadAndPoint*) other {
  if (other == [TSS_DrivingRoute_RoadAndPoint defaultInstance]) {
    return self;
  }
  if (other.hasRoad) {
    [self setRoad:other.road];
  }
  if (other.hasEnd) {
    [self mergeEnd:other.end];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSS_DrivingRoute_RoadAndPoint_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSS_DrivingRoute_RoadAndPoint_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setRoad:[input readString]];
        break;
      }
      case 18: {
        TSS_Point_Builder* subBuilder = [TSS_Point builder];
        if (self.hasEnd) {
          [subBuilder mergeFrom:self.end];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setEnd:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasRoad {
  return result.hasRoad;
}
- (NSString*) road {
  return result.road;
}
- (TSS_DrivingRoute_RoadAndPoint_Builder*) setRoad:(NSString*) value {
  result.hasRoad = YES;
  result.road = value;
  return self;
}
- (TSS_DrivingRoute_RoadAndPoint_Builder*) clearRoad {
  result.hasRoad = NO;
  result.road = @"";
  return self;
}
- (BOOL) hasEnd {
  return result.hasEnd;
}
- (TSS_Point*) end {
  return result.end;
}
- (TSS_DrivingRoute_RoadAndPoint_Builder*) setEnd:(TSS_Point*) value {
  result.hasEnd = YES;
  result.end = value;
  return self;
}
- (TSS_DrivingRoute_RoadAndPoint_Builder*) setEndBuilder:(TSS_Point_Builder*) builderForValue {
  return [self setEnd:[builderForValue build]];
}
- (TSS_DrivingRoute_RoadAndPoint_Builder*) mergeEnd:(TSS_Point*) value {
  if (result.hasEnd &&
      result.end != [TSS_Point defaultInstance]) {
    result.end =
      [[[TSS_Point builderWithPrototype:result.end] mergeFrom:value] buildPartial];
  } else {
    result.end = value;
  }
  result.hasEnd = YES;
  return self;
}
- (TSS_DrivingRoute_RoadAndPoint_Builder*) clearEnd {
  result.hasEnd = NO;
  result.end = [TSS_Point defaultInstance];
  return self;
}
@end

@interface TSS_DrivingRoute_Builder()
@property (retain) TSS_DrivingRoute* result;
@end

@implementation TSS_DrivingRoute_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSS_DrivingRoute alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSS_DrivingRoute_Builder*) clear {
  self.result = [[[TSS_DrivingRoute alloc] init] autorelease];
  return self;
}
- (TSS_DrivingRoute_Builder*) clone {
  return [TSS_DrivingRoute builderWithPrototype:result];
}
- (TSS_DrivingRoute*) defaultInstance {
  return [TSS_DrivingRoute defaultInstance];
}
- (TSS_DrivingRoute*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSS_DrivingRoute*) buildPartial {
  TSS_DrivingRoute* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSS_DrivingRoute_Builder*) mergeFrom:(TSS_DrivingRoute*) other {
  if (other == [TSS_DrivingRoute defaultInstance]) {
    return self;
  }
  if (other.hasStart) {
    [self mergeStart:other.start];
  }
  if (other.mutableSegmentList.count > 0) {
    if (result.mutableSegmentList == nil) {
      result.mutableSegmentList = [NSMutableArray array];
    }
    [result.mutableSegmentList addObjectsFromArray:other.mutableSegmentList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSS_DrivingRoute_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSS_DrivingRoute_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        TSS_Point_Builder* subBuilder = [TSS_Point builder];
        if (self.hasStart) {
          [subBuilder mergeFrom:self.start];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setStart:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        TSS_DrivingRoute_RoadAndPoint_Builder* subBuilder = [TSS_DrivingRoute_RoadAndPoint builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addSegment:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasStart {
  return result.hasStart;
}
- (TSS_Point*) start {
  return result.start;
}
- (TSS_DrivingRoute_Builder*) setStart:(TSS_Point*) value {
  result.hasStart = YES;
  result.start = value;
  return self;
}
- (TSS_DrivingRoute_Builder*) setStartBuilder:(TSS_Point_Builder*) builderForValue {
  return [self setStart:[builderForValue build]];
}
- (TSS_DrivingRoute_Builder*) mergeStart:(TSS_Point*) value {
  if (result.hasStart &&
      result.start != [TSS_Point defaultInstance]) {
    result.start =
      [[[TSS_Point builderWithPrototype:result.start] mergeFrom:value] buildPartial];
  } else {
    result.start = value;
  }
  result.hasStart = YES;
  return self;
}
- (TSS_DrivingRoute_Builder*) clearStart {
  result.hasStart = NO;
  result.start = [TSS_Point defaultInstance];
  return self;
}
- (NSArray*) segmentList {
  if (result.mutableSegmentList == nil) { return [NSArray array]; }
  return result.mutableSegmentList;
}
- (TSS_DrivingRoute_RoadAndPoint*) segmentAtIndex:(int32_t) index {
  return [result segmentAtIndex:index];
}
- (TSS_DrivingRoute_Builder*) replaceSegmentAtIndex:(int32_t) index with:(TSS_DrivingRoute_RoadAndPoint*) value {
  [result.mutableSegmentList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (TSS_DrivingRoute_Builder*) addAllSegment:(NSArray*) values {
  if (result.mutableSegmentList == nil) {
    result.mutableSegmentList = [NSMutableArray array];
  }
  [result.mutableSegmentList addObjectsFromArray:values];
  return self;
}
- (TSS_DrivingRoute_Builder*) clearSegmentList {
  result.mutableSegmentList = nil;
  return self;
}
- (TSS_DrivingRoute_Builder*) addSegment:(TSS_DrivingRoute_RoadAndPoint*) value {
  if (result.mutableSegmentList == nil) {
    result.mutableSegmentList = [NSMutableArray array];
  }
  [result.mutableSegmentList addObject:value];
  return self;
}
@end

@interface TSS_SegmentTraffic ()
@property (retain) TSS_Line* segment;
@property (retain) TSS_Point* location;
@property int32_t direction;
@property int32_t speed;
@property (retain) NSString* details;
@end

@implementation TSS_SegmentTraffic

- (BOOL) hasSegment {
  return !!hasSegment_;
}
- (void) setHasSegment:(BOOL) value {
  hasSegment_ = !!value;
}
@synthesize segment;
- (BOOL) hasLocation {
  return !!hasLocation_;
}
- (void) setHasLocation:(BOOL) value {
  hasLocation_ = !!value;
}
@synthesize location;
- (BOOL) hasDirection {
  return !!hasDirection_;
}
- (void) setHasDirection:(BOOL) value {
  hasDirection_ = !!value;
}
@synthesize direction;
- (BOOL) hasSpeed {
  return !!hasSpeed_;
}
- (void) setHasSpeed:(BOOL) value {
  hasSpeed_ = !!value;
}
@synthesize speed;
- (BOOL) hasDetails {
  return !!hasDetails_;
}
- (void) setHasDetails:(BOOL) value {
  hasDetails_ = !!value;
}
@synthesize details;
- (void) dealloc {
  self.segment = nil;
  self.location = nil;
  self.details = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.segment = [TSS_Line defaultInstance];
    self.location = [TSS_Point defaultInstance];
    self.direction = 0;
    self.speed = 0;
    self.details = @"";
  }
  return self;
}
static TSS_SegmentTraffic* defaultTSS_SegmentTrafficInstance = nil;
+ (void) initialize {
  if (self == [TSS_SegmentTraffic class]) {
    defaultTSS_SegmentTrafficInstance = [[TSS_SegmentTraffic alloc] init];
  }
}
+ (TSS_SegmentTraffic*) defaultInstance {
  return defaultTSS_SegmentTrafficInstance;
}
- (TSS_SegmentTraffic*) defaultInstance {
  return defaultTSS_SegmentTrafficInstance;
}
- (BOOL) isInitialized {
  if (!self.hasDirection) {
      NSLog(@"[Reason: TSS_SegmentTraffic NO Direction]");
    return NO;
  }
  if (!self.hasSpeed) {
      NSLog(@"[Reason: TSS_SegmentTraffic NO Speed]");
    return NO;
  }
  if (self.hasSegment) {
    if (!self.segment.isInitialized) {
        NSLog(@"[Reason: TSS_SegmentTraffic NO Segment]");
      return NO;
    }
  }
  if (self.hasLocation) {
    if (!self.location.isInitialized) {
        NSLog(@"[Reason: TSS_SegmentTraffic NO Location]");
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasSegment) {
    [output writeMessage:1 value:self.segment];
  }
  if (self.hasLocation) {
    [output writeMessage:2 value:self.location];
  }
  if (self.hasDirection) {
    [output writeInt32:3 value:self.direction];
  }
  if (self.hasSpeed) {
    [output writeInt32:4 value:self.speed];
  }
  if (self.hasDetails) {
    [output writeString:5 value:self.details];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasSegment) {
    size += computeMessageSize(1, self.segment);
  }
  if (self.hasLocation) {
    size += computeMessageSize(2, self.location);
  }
  if (self.hasDirection) {
    size += computeInt32Size(3, self.direction);
  }
  if (self.hasSpeed) {
    size += computeInt32Size(4, self.speed);
  }
  if (self.hasDetails) {
    size += computeStringSize(5, self.details);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSS_SegmentTraffic*) parseFromData:(NSData*) data {
  return (TSS_SegmentTraffic*)[[[TSS_SegmentTraffic builder] mergeFromData:data] build];
}
+ (TSS_SegmentTraffic*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_SegmentTraffic*)[[[TSS_SegmentTraffic builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSS_SegmentTraffic*) parseFromInputStream:(NSInputStream*) input {
  return (TSS_SegmentTraffic*)[[[TSS_SegmentTraffic builder] mergeFromInputStream:input] build];
}
+ (TSS_SegmentTraffic*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_SegmentTraffic*)[[[TSS_SegmentTraffic builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_SegmentTraffic*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSS_SegmentTraffic*)[[[TSS_SegmentTraffic builder] mergeFromCodedInputStream:input] build];
}
+ (TSS_SegmentTraffic*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_SegmentTraffic*)[[[TSS_SegmentTraffic builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_SegmentTraffic_Builder*) builder {
  return [[[TSS_SegmentTraffic_Builder alloc] init] autorelease];
}
+ (TSS_SegmentTraffic_Builder*) builderWithPrototype:(TSS_SegmentTraffic*) prototype {
  return [[TSS_SegmentTraffic builder] mergeFrom:prototype];
}
- (TSS_SegmentTraffic_Builder*) builder {
  return [TSS_SegmentTraffic builder];
}
@end

@interface TSS_SegmentTraffic_Builder()
@property (retain) TSS_SegmentTraffic* result;
@end

@implementation TSS_SegmentTraffic_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSS_SegmentTraffic alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSS_SegmentTraffic_Builder*) clear {
  self.result = [[[TSS_SegmentTraffic alloc] init] autorelease];
  return self;
}
- (TSS_SegmentTraffic_Builder*) clone {
  return [TSS_SegmentTraffic builderWithPrototype:result];
}
- (TSS_SegmentTraffic*) defaultInstance {
  return [TSS_SegmentTraffic defaultInstance];
}
- (TSS_SegmentTraffic*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSS_SegmentTraffic*) buildPartial {
  TSS_SegmentTraffic* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSS_SegmentTraffic_Builder*) mergeFrom:(TSS_SegmentTraffic*) other {
  if (other == [TSS_SegmentTraffic defaultInstance]) {
    return self;
  }
  if (other.hasSegment) {
    [self mergeSegment:other.segment];
  }
  if (other.hasLocation) {
    [self mergeLocation:other.location];
  }
  if (other.hasDirection) {
    [self setDirection:other.direction];
  }
  if (other.hasSpeed) {
    [self setSpeed:other.speed];
  }
  if (other.hasDetails) {
    [self setDetails:other.details];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSS_SegmentTraffic_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSS_SegmentTraffic_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        TSS_Line_Builder* subBuilder = [TSS_Line builder];
        if (self.hasSegment) {
          [subBuilder mergeFrom:self.segment];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setSegment:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        TSS_Point_Builder* subBuilder = [TSS_Point builder];
        if (self.hasLocation) {
          [subBuilder mergeFrom:self.location];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setLocation:[subBuilder buildPartial]];
        break;
      }
      case 24: {
        [self setDirection:[input readInt32]];
        break;
      }
      case 32: {
        [self setSpeed:[input readInt32]];
        break;
      }
      case 42: {
        [self setDetails:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasSegment {
  return result.hasSegment;
}
- (TSS_Line*) segment {
  return result.segment;
}
- (TSS_SegmentTraffic_Builder*) setSegment:(TSS_Line*) value {
  result.hasSegment = YES;
  result.segment = value;
  return self;
}
- (TSS_SegmentTraffic_Builder*) setSegmentBuilder:(TSS_Line_Builder*) builderForValue {
  return [self setSegment:[builderForValue build]];
}
- (TSS_SegmentTraffic_Builder*) mergeSegment:(TSS_Line*) value {
  if (result.hasSegment &&
      result.segment != [TSS_Line defaultInstance]) {
    result.segment =
      [[[TSS_Line builderWithPrototype:result.segment] mergeFrom:value] buildPartial];
  } else {
    result.segment = value;
  }
  result.hasSegment = YES;
  return self;
}
- (TSS_SegmentTraffic_Builder*) clearSegment {
  result.hasSegment = NO;
  result.segment = [TSS_Line defaultInstance];
  return self;
}
- (BOOL) hasLocation {
  return result.hasLocation;
}
- (TSS_Point*) location {
  return result.location;
}
- (TSS_SegmentTraffic_Builder*) setLocation:(TSS_Point*) value {
  result.hasLocation = YES;
  result.location = value;
  return self;
}
- (TSS_SegmentTraffic_Builder*) setLocationBuilder:(TSS_Point_Builder*) builderForValue {
  return [self setLocation:[builderForValue build]];
}
- (TSS_SegmentTraffic_Builder*) mergeLocation:(TSS_Point*) value {
  if (result.hasLocation &&
      result.location != [TSS_Point defaultInstance]) {
    result.location =
      [[[TSS_Point builderWithPrototype:result.location] mergeFrom:value] buildPartial];
  } else {
    result.location = value;
  }
  result.hasLocation = YES;
  return self;
}
- (TSS_SegmentTraffic_Builder*) clearLocation {
  result.hasLocation = NO;
  result.location = [TSS_Point defaultInstance];
  return self;
}
- (BOOL) hasDirection {
  return result.hasDirection;
}
- (int32_t) direction {
  return result.direction;
}
- (TSS_SegmentTraffic_Builder*) setDirection:(int32_t) value {
  result.hasDirection = YES;
  result.direction = value;
  return self;
}
- (TSS_SegmentTraffic_Builder*) clearDirection {
  result.hasDirection = NO;
  result.direction = 0;
  return self;
}
- (BOOL) hasSpeed {
  return result.hasSpeed;
}
- (int32_t) speed {
  return result.speed;
}
- (TSS_SegmentTraffic_Builder*) setSpeed:(int32_t) value {
  result.hasSpeed = YES;
  result.speed = value;
  return self;
}
- (TSS_SegmentTraffic_Builder*) clearSpeed {
  result.hasSpeed = NO;
  result.speed = 0;
  return self;
}
- (BOOL) hasDetails {
  return result.hasDetails;
}
- (NSString*) details {
  return result.details;
}
- (TSS_SegmentTraffic_Builder*) setDetails:(NSString*) value {
  result.hasDetails = YES;
  result.details = value;
  return self;
}
- (TSS_SegmentTraffic_Builder*) clearDetails {
  result.hasDetails = NO;
  result.details = @"";
  return self;
}
@end

@interface TSS_RoadTraffic ()
@property (retain) NSString* road;
@property (retain) NSString* desc;
@property (retain) NSMutableArray* mutableSegmenttrafficList;
@end

@implementation TSS_RoadTraffic

- (BOOL) hasRoad {
  return !!hasRoad_;
}
- (void) setHasRoad:(BOOL) value {
  hasRoad_ = !!value;
}
@synthesize road;
- (BOOL) hasDesc {
  return !!hasDesc_;
}
- (void) setHasDesc:(BOOL) value {
  hasDesc_ = !!value;
}
@synthesize desc;
@synthesize mutableSegmenttrafficList;
- (void) dealloc {
  self.road = nil;
  self.desc = nil;
  self.mutableSegmenttrafficList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.road = @"";
    self.desc = @"";
  }
  return self;
}
static TSS_RoadTraffic* defaultTSS_RoadTrafficInstance = nil;
+ (void) initialize {
  if (self == [TSS_RoadTraffic class]) {
    defaultTSS_RoadTrafficInstance = [[TSS_RoadTraffic alloc] init];
  }
}
+ (TSS_RoadTraffic*) defaultInstance {
  return defaultTSS_RoadTrafficInstance;
}
- (TSS_RoadTraffic*) defaultInstance {
  return defaultTSS_RoadTrafficInstance;
}
- (NSArray*) segmenttrafficList {
  return mutableSegmenttrafficList;
}
- (TSS_SegmentTraffic*) segmenttrafficAtIndex:(int32_t) index {
  id value = [mutableSegmenttrafficList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasRoad) {
      //NSLog(@"%@, %@, %d\n, [Reason: TSS_RoadTraffic NO Road]", __FILE__, __FUNCTION__, __LINE__);
      NSLog(@"[Reason: TSS_RoadTraffic NO Road]");
      return NO;
  }
  for (TSS_SegmentTraffic* element in self.segmenttrafficList) {
    if (!element.isInitialized) {
        NSLog(@"[Reason: TSS_RoadTraffic NO element init]");
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasRoad) {
    [output writeString:1 value:self.road];
  }
  if (self.hasDesc) {
    [output writeString:2 value:self.desc];
  }
  for (TSS_SegmentTraffic* element in self.segmenttrafficList) {
    [output writeMessage:3 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasRoad) {
    size += computeStringSize(1, self.road);
  }
  if (self.hasDesc) {
    size += computeStringSize(2, self.desc);
  }
  for (TSS_SegmentTraffic* element in self.segmenttrafficList) {
    size += computeMessageSize(3, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSS_RoadTraffic*) parseFromData:(NSData*) data {
  return (TSS_RoadTraffic*)[[[TSS_RoadTraffic builder] mergeFromData:data] build];
}
+ (TSS_RoadTraffic*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_RoadTraffic*)[[[TSS_RoadTraffic builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSS_RoadTraffic*) parseFromInputStream:(NSInputStream*) input {
  return (TSS_RoadTraffic*)[[[TSS_RoadTraffic builder] mergeFromInputStream:input] build];
}
+ (TSS_RoadTraffic*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_RoadTraffic*)[[[TSS_RoadTraffic builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_RoadTraffic*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSS_RoadTraffic*)[[[TSS_RoadTraffic builder] mergeFromCodedInputStream:input] build];
}
+ (TSS_RoadTraffic*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_RoadTraffic*)[[[TSS_RoadTraffic builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_RoadTraffic_Builder*) builder {
  return [[[TSS_RoadTraffic_Builder alloc] init] autorelease];
}
+ (TSS_RoadTraffic_Builder*) builderWithPrototype:(TSS_RoadTraffic*) prototype {
  return [[TSS_RoadTraffic builder] mergeFrom:prototype];
}
- (TSS_RoadTraffic_Builder*) builder {
  return [TSS_RoadTraffic builder];
}
@end

@interface TSS_RoadTraffic_Builder()
@property (retain) TSS_RoadTraffic* result;
@end

@implementation TSS_RoadTraffic_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSS_RoadTraffic alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSS_RoadTraffic_Builder*) clear {
  self.result = [[[TSS_RoadTraffic alloc] init] autorelease];
  return self;
}
- (TSS_RoadTraffic_Builder*) clone {
  return [TSS_RoadTraffic builderWithPrototype:result];
}
- (TSS_RoadTraffic*) defaultInstance {
  return [TSS_RoadTraffic defaultInstance];
}
- (TSS_RoadTraffic*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSS_RoadTraffic*) buildPartial {
  TSS_RoadTraffic* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSS_RoadTraffic_Builder*) mergeFrom:(TSS_RoadTraffic*) other {
  if (other == [TSS_RoadTraffic defaultInstance]) {
    return self;
  }
  if (other.hasRoad) {
    [self setRoad:other.road];
  }
  if (other.hasDesc) {
    [self setDesc:other.desc];
  }
  if (other.mutableSegmenttrafficList.count > 0) {
    if (result.mutableSegmenttrafficList == nil) {
      result.mutableSegmenttrafficList = [NSMutableArray array];
    }
    [result.mutableSegmenttrafficList addObjectsFromArray:other.mutableSegmenttrafficList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSS_RoadTraffic_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSS_RoadTraffic_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setRoad:[input readString]];
        break;
      }
      case 18: {
        [self setDesc:[input readString]];
        break;
      }
      case 26: {
        TSS_SegmentTraffic_Builder* subBuilder = [TSS_SegmentTraffic builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addSegmenttraffic:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasRoad {
  return result.hasRoad;
}
- (NSString*) road {
  return result.road;
}
- (TSS_RoadTraffic_Builder*) setRoad:(NSString*) value {
  result.hasRoad = YES;
  result.road = value;
  return self;
}
- (TSS_RoadTraffic_Builder*) clearRoad {
  result.hasRoad = NO;
  result.road = @"";
  return self;
}
- (BOOL) hasDesc {
  return result.hasDesc;
}
- (NSString*) desc {
  return result.desc;
}
- (TSS_RoadTraffic_Builder*) setDesc:(NSString*) value {
  result.hasDesc = YES;
  result.desc = value;
  return self;
}
- (TSS_RoadTraffic_Builder*) clearDesc {
  result.hasDesc = NO;
  result.desc = @"";
  return self;
}
- (NSArray*) segmenttrafficList {
  if (result.mutableSegmenttrafficList == nil) { return [NSArray array]; }
  return result.mutableSegmenttrafficList;
}
- (TSS_SegmentTraffic*) segmenttrafficAtIndex:(int32_t) index {
  return [result segmenttrafficAtIndex:index];
}
- (TSS_RoadTraffic_Builder*) replaceSegmenttrafficAtIndex:(int32_t) index with:(TSS_SegmentTraffic*) value {
  [result.mutableSegmenttrafficList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (TSS_RoadTraffic_Builder*) addAllSegmenttraffic:(NSArray*) values {
  if (result.mutableSegmenttrafficList == nil) {
    result.mutableSegmenttrafficList = [NSMutableArray array];
  }
  [result.mutableSegmenttrafficList addObjectsFromArray:values];
  return self;
}
- (TSS_RoadTraffic_Builder*) clearSegmenttrafficList {
  result.mutableSegmenttrafficList = nil;
  return self;
}
- (TSS_RoadTraffic_Builder*) addSegmenttraffic:(TSS_SegmentTraffic*) value {
  if (result.mutableSegmenttrafficList == nil) {
    result.mutableSegmenttrafficList = [NSMutableArray array];
  }
  [result.mutableSegmenttrafficList addObject:value];
  return self;
}
@end

@interface TSS_CityTraffic ()
@property (retain) NSString* city;
@property int32_t recorded;
@property (retain) NSMutableArray* mutableRoadtrafficList;
@end

@implementation TSS_CityTraffic

- (BOOL) hasCity {
  return !!hasCity_;
}
- (void) setHasCity:(BOOL) value {
  hasCity_ = !!value;
}
@synthesize city;
- (BOOL) hasRecorded {
  return !!hasRecorded_;
}
- (void) setHasRecorded:(BOOL) value {
  hasRecorded_ = !!value;
}
@synthesize recorded;
@synthesize mutableRoadtrafficList;
- (void) dealloc {
  self.city = nil;
  self.mutableRoadtrafficList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.city = @"";
    self.recorded = 0;
  }
  return self;
}
static TSS_CityTraffic* defaultTSS_CityTrafficInstance = nil;
+ (void) initialize {
  if (self == [TSS_CityTraffic class]) {
    defaultTSS_CityTrafficInstance = [[TSS_CityTraffic alloc] init];
  }
}
+ (TSS_CityTraffic*) defaultInstance {
  return defaultTSS_CityTrafficInstance;
}
- (TSS_CityTraffic*) defaultInstance {
  return defaultTSS_CityTrafficInstance;
}
- (NSArray*) roadtrafficList {
  return mutableRoadtrafficList;
}
- (TSS_RoadTraffic*) roadtrafficAtIndex:(int32_t) index {
  id value = [mutableRoadtrafficList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasRecorded) {
      NSLog(@"[Reason: TSS_CityTraffic NO Recorded]");
    return NO;
  }
  for (TSS_RoadTraffic* element in self.roadtrafficList) {
    if (!element.isInitialized) {
        NSLog(@"[Reason: TSS_CityTraffic NO element init]");
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasCity) {
    [output writeString:1 value:self.city];
  }
  if (self.hasRecorded) {
    [output writeInt32:2 value:self.recorded];
  }
  for (TSS_RoadTraffic* element in self.roadtrafficList) {
    [output writeMessage:3 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasCity) {
    size += computeStringSize(1, self.city);
  }
  if (self.hasRecorded) {
    size += computeInt32Size(2, self.recorded);
  }
  for (TSS_RoadTraffic* element in self.roadtrafficList) {
    size += computeMessageSize(3, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (TSS_CityTraffic*) parseFromData:(NSData*) data {
  return (TSS_CityTraffic*)[[[TSS_CityTraffic builder] mergeFromData:data] build];
}
+ (TSS_CityTraffic*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_CityTraffic*)[[[TSS_CityTraffic builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (TSS_CityTraffic*) parseFromInputStream:(NSInputStream*) input {
  return (TSS_CityTraffic*)[[[TSS_CityTraffic builder] mergeFromInputStream:input] build];
}
+ (TSS_CityTraffic*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_CityTraffic*)[[[TSS_CityTraffic builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_CityTraffic*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (TSS_CityTraffic*)[[[TSS_CityTraffic builder] mergeFromCodedInputStream:input] build];
}
+ (TSS_CityTraffic*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (TSS_CityTraffic*)[[[TSS_CityTraffic builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (TSS_CityTraffic_Builder*) builder {
  return [[[TSS_CityTraffic_Builder alloc] init] autorelease];
}
+ (TSS_CityTraffic_Builder*) builderWithPrototype:(TSS_CityTraffic*) prototype {
  return [[TSS_CityTraffic builder] mergeFrom:prototype];
}
- (TSS_CityTraffic_Builder*) builder {
  return [TSS_CityTraffic builder];
}
@end

@interface TSS_CityTraffic_Builder()
@property (retain) TSS_CityTraffic* result;
@end

@implementation TSS_CityTraffic_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[TSS_CityTraffic alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (TSS_CityTraffic_Builder*) clear {
  self.result = [[[TSS_CityTraffic alloc] init] autorelease];
  return self;
}
- (TSS_CityTraffic_Builder*) clone {
  return [TSS_CityTraffic builderWithPrototype:result];
}
- (TSS_CityTraffic*) defaultInstance {
  return [TSS_CityTraffic defaultInstance];
}
- (TSS_CityTraffic*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (TSS_CityTraffic*) buildPartial {
  TSS_CityTraffic* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (TSS_CityTraffic_Builder*) mergeFrom:(TSS_CityTraffic*) other {
  if (other == [TSS_CityTraffic defaultInstance]) {
    return self;
  }
  if (other.hasCity) {
    [self setCity:other.city];
  }
  if (other.hasRecorded) {
    [self setRecorded:other.recorded];
  }
  if (other.mutableRoadtrafficList.count > 0) {
    if (result.mutableRoadtrafficList == nil) {
      result.mutableRoadtrafficList = [NSMutableArray array];
    }
    [result.mutableRoadtrafficList addObjectsFromArray:other.mutableRoadtrafficList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (TSS_CityTraffic_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (TSS_CityTraffic_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setCity:[input readString]];
        break;
      }
      case 16: {
        [self setRecorded:[input readInt32]];
        break;
      }
      case 26: {
        TSS_RoadTraffic_Builder* subBuilder = [TSS_RoadTraffic builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addRoadtraffic:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasCity {
  return result.hasCity;
}
- (NSString*) city {
  return result.city;
}
- (TSS_CityTraffic_Builder*) setCity:(NSString*) value {
  result.hasCity = YES;
  result.city = value;
  return self;
}
- (TSS_CityTraffic_Builder*) clearCity {
  result.hasCity = NO;
  result.city = @"";
  return self;
}
- (BOOL) hasRecorded {
  return result.hasRecorded;
}
- (int32_t) recorded {
  return result.recorded;
}
- (TSS_CityTraffic_Builder*) setRecorded:(int32_t) value {
  result.hasRecorded = YES;
  result.recorded = value;
  return self;
}
- (TSS_CityTraffic_Builder*) clearRecorded {
  result.hasRecorded = NO;
  result.recorded = 0;
  return self;
}
- (NSArray*) roadtrafficList {
  if (result.mutableRoadtrafficList == nil) { return [NSArray array]; }
  return result.mutableRoadtrafficList;
}
- (TSS_RoadTraffic*) roadtrafficAtIndex:(int32_t) index {
  return [result roadtrafficAtIndex:index];
}
- (TSS_CityTraffic_Builder*) replaceRoadtrafficAtIndex:(int32_t) index with:(TSS_RoadTraffic*) value {
  [result.mutableRoadtrafficList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (TSS_CityTraffic_Builder*) addAllRoadtraffic:(NSArray*) values {
  if (result.mutableRoadtrafficList == nil) {
    result.mutableRoadtrafficList = [NSMutableArray array];
  }
  [result.mutableRoadtrafficList addObjectsFromArray:values];
  return self;
}
- (TSS_CityTraffic_Builder*) clearRoadtrafficList {
  result.mutableRoadtrafficList = nil;
  return self;
}
- (TSS_CityTraffic_Builder*) addRoadtraffic:(TSS_RoadTraffic*) value {
  if (result.mutableRoadtrafficList == nil) {
    result.mutableRoadtrafficList = [NSMutableArray array];
  }
  [result.mutableRoadtrafficList addObject:value];
  return self;
}
@end

